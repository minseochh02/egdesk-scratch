import path from 'path';
import { ipcMain } from 'electron';

export function registerSEOHandlers() {
  ipcMain.handle('generate-lighthouse-reports', async (event, { urls, proxy }) => {
    try {
      const { chromium } = require('playwright');
      const { playAudit } = require('playwright-lighthouse');
      const fs = require('fs');
      const outputDir = path.join(process.cwd(), 'output');

      console.log(`üîç Starting batch Lighthouse generation for ${urls.length} URLs...`);

      // Build proxy option if provided
      let proxyOption: any;
      if (proxy) {
        try {
          const proxyUrl = new URL(proxy);
          proxyOption = {
            server: `${proxyUrl.protocol}//${proxyUrl.host}`,
            username: proxyUrl.username || undefined,
            password: proxyUrl.password || undefined,
          };
        } catch {
          console.warn('Invalid proxy URL, ignoring proxy option');
        }
      }

      if (!fs.existsSync(outputDir)) {
        fs.mkdirSync(outputDir, { recursive: true });
      }

      const results: any[] = [];
      const debugPort = Math.floor(Math.random() * 10000) + 9000;

      const browser = await chromium.launch({
        headless: false,
        channel: 'chrome',
        proxy: proxyOption,
        args: [
          `--remote-debugging-port=${debugPort}`,
          '--lang=ko',
          '--enable-features=Lighthouse',
          '--disable-web-security',
          '--disable-features=VizDisplayCompositor',
        ],
      });

      const context = await browser.newContext({ locale: 'ko-KR' });

      for (let i = 0; i < urls.length; i++) {
        const url = urls[i];
        const urlResult = {
          url,
          success: false,
          reportName: null as string | null,
          error: null as string | null,
          index: i + 1,
          total: urls.length,
        };

        try {
          event.sender.send('lighthouse-progress', {
            current: i + 1,
            total: urls.length,
            url,
            status: 'processing',
          });

          const page = await context.newPage();
          await page.goto(url, { waitUntil: 'networkidle' });
          await page.waitForLoadState('networkidle');
          await page.waitForTimeout(2000);

          const timestamp = Date.now();
          const sanitizedUrl = url.replace(/[^a-zA-Z0-9]/g, '_').substring(0, 50);
          const reportName = `lighthouse-${sanitizedUrl}-${timestamp}`;

          await playAudit({
            page,
            port: debugPort,
            opts: { locale: 'ko' },
            thresholds: {
              performance: 50,
              accessibility: 50,
              'best-practices': 50,
              seo: 50,
              pwa: 50,
            },
            reports: {
              formats: { html: true, json: true },
              name: reportName,
              directory: outputDir,
            },
          });

          // Generate PDF: expand sections and print
          try {
            const htmlReportPath = `file://${path.join(outputDir, `${reportName}.html`)}`;
            const pdfPage = await context.newPage();
            await pdfPage.goto(htmlReportPath);
            await pdfPage.waitForLoadState('networkidle');
            await pdfPage.waitForTimeout(2000);
            await pdfPage.evaluate(() => {
              document.querySelectorAll('details').forEach((d: any) => (d.open = true));
              document.querySelectorAll('[aria-expanded="false"]').forEach((el: any) => el.setAttribute('aria-expanded', 'true'));
              document.querySelectorAll('.lh-collapsed, .collapsed').forEach((el: any) => el.classList.remove('lh-collapsed', 'collapsed'));
            });
            await pdfPage.waitForTimeout(1000);
            const pdfPath = path.join(outputDir, `${reportName}.pdf`);
            await pdfPage.pdf({
              path: pdfPath,
              format: 'A4',
              printBackground: true,
              margin: { top: '20px', right: '20px', bottom: '20px', left: '20px' },
            });
            await pdfPage.close();
          } catch (pdfError) {
            console.error('‚ùå PDF generation failed:', pdfError);
          }

          urlResult.success = true;
          urlResult.reportName = reportName;

          event.sender.send('lighthouse-progress', {
            current: i + 1,
            total: urls.length,
            url,
            status: 'completed',
            reportName,
          });

          await page.close();
        } catch (error: any) {
          console.error(`‚ùå Failed to process ${url}:`, error);
          urlResult.error = error?.message || 'Unknown error';
          event.sender.send('lighthouse-progress', {
            current: i + 1,
            total: urls.length,
            url,
            status: 'failed',
            error: urlResult.error,
          });
        }

        results.push(urlResult);
      }

      // Merge JSON and synthesize reports and summary
      const fs = require('fs');
      const allJsonData: any[] = [];
      const successfulResults = results.filter((r) => r.success && r.reportName);
      const mergedJsonPath = path.join(outputDir, `merged-lighthouse-${Date.now()}.json`);
      for (const result of successfulResults) {
        try {
          const jsonPath = path.join(outputDir, `${result.reportName}.json`);
          if (fs.existsSync(jsonPath)) {
            const jsonData = JSON.parse(fs.readFileSync(jsonPath, 'utf8'));
            allJsonData.push({ url: result.url, reportName: result.reportName, data: jsonData });
          }
        } catch (err) {
          console.error(`Failed to read JSON for ${result.url}:`, err);
        }
      }
      fs.writeFileSync(mergedJsonPath, JSON.stringify(allJsonData, null, 2));

      // Aggregate scores
      const scores: any[] = [];
      let totalPerformance = 0;
      let totalAccessibility = 0;
      let totalBestPractices = 0;
      let totalSEO = 0;
      let totalPWA = 0;
      let validScoresCount = 0;
      for (const jsonItem of allJsonData) {
        const lhr = jsonItem.data?.lhr || jsonItem.data;
        if (lhr?.categories) {
          const perf = lhr.categories.performance?.score || 0;
          const a11y = lhr.categories.accessibility?.score || 0;
          const bp = lhr.categories['best-practices']?.score || 0;
          const seo = lhr.categories.seo?.score || 0;
          const pwa = lhr.categories.pwa?.score || 0;
          scores.push({
            url: jsonItem.url,
            performance: Math.round(perf * 100),
            accessibility: Math.round(a11y * 100),
            bestPractices: Math.round(bp * 100),
            seo: Math.round(seo * 100),
            pwa: Math.round(pwa * 100),
            average: Math.round(((perf + a11y + bp + seo + pwa) / 5) * 100),
          });
          totalPerformance += perf;
          totalAccessibility += a11y;
          totalBestPractices += bp;
          totalSEO += seo;
          totalPWA += pwa;
          validScoresCount++;
        }
      }
      const avgPerformance = validScoresCount > 0 ? Math.round((totalPerformance / validScoresCount) * 100) : 0;
      const avgAccessibility = validScoresCount > 0 ? Math.round((totalAccessibility / validScoresCount) * 100) : 0;
      const avgBestPractices = validScoresCount > 0 ? Math.round((totalBestPractices / validScoresCount) * 100) : 0;
      const avgSEO = validScoresCount > 0 ? Math.round((totalSEO / validScoresCount) * 100) : 0;
      const avgPWA = validScoresCount > 0 ? Math.round((totalPWA / validScoresCount) * 100) : 0;
      const overallAverage = validScoresCount > 0 ? Math.round(((totalPerformance + totalAccessibility + totalBestPractices + totalSEO + totalPWA) / (validScoresCount * 5)) * 100) : 0;

      // Collect issues by category
      const issuesByCategory: { [key: string]: Set<string> } = {
        performance: new Set(),
        accessibility: new Set(),
        'best-practices': new Set(),
        seo: new Set(),
        pwa: new Set(),
      };
      for (const jsonItem of allJsonData) {
        const lhr = jsonItem.data?.lhr || jsonItem.data;
        if (lhr?.audits) {
          Object.entries(lhr.audits).forEach(([key, audit]: [string, any]) => {
            if (audit.score !== null && audit.score < 1 && audit.score !== -1) {
              const category = Object.keys(lhr.categories || {}).find((cat) => {
                const categoryAudits = lhr.categories[cat]?.auditRefs || [];
                return categoryAudits.some((ref: any) => ref.id === key);
              }) || 'other';
              if (issuesByCategory[category]) {
                issuesByCategory[category].add(audit.title);
              }
            }
          });
        }
      }

      // Generate final report HTML (simplified): keep same as before
      const getScoreColor = (score: number) => {
        if (score >= 90) return '#0cce6b';
        if (score >= 50) return '#ffa400';
        return '#ff4e42';
      };

      let aiExplanation = '';
      try {
        const { getStore } = require('../storage');
        const store = getStore();
        const aiKeys = store ? store.get('ai-keys', []) : [];
        let googleKey: any = null;
        if (Array.isArray(aiKeys)) {
          const egdeskKey = aiKeys.find((k: any) => (k?.name || '').toLowerCase() === 'egdesk' && k?.providerId === 'google');
          googleKey = egdeskKey || aiKeys.find((k: any) => k?.providerId === 'google' && k?.isActive) || aiKeys.find((k: any) => k?.providerId === 'google');
        }
        const geminiApiKey = googleKey?.fields?.apiKey || process.env.GEMINI_API_KEY || '';
        if (geminiApiKey) {
          const issuesSummary = Object.entries(issuesByCategory)
            .filter(([_, issues]) => (issues as Set<string>).size > 0)
            .map(([category, issues]) => `${category}: ${Array.from(issues as Set<string>).join(', ')}`)
            .join('\n');
          const prompt = `ÎãπÏã†ÏùÄ SEO Ï†ÑÎ¨∏Í∞ÄÏûÖÎãàÎã§. ÏõπÏÇ¨Ïù¥Ìä∏ Î∂ÑÏÑù Í≤∞Í≥º Î∞úÍ≤¨Îêú Îã§Ïùå Î¨∏Ï†úÎì§ÏùÑ SEOÏóê ÎåÄÌï¥ Ï†ÑÌòÄ Î™®Î•¥Îäî ÏùºÎ∞ò ÏÇ¨Ïö©ÏûêÍ∞Ä Ïù¥Ìï¥Ìï† Ïàò ÏûàÎèÑÎ°ù ÏâΩÍ≥† ÏπúÏ†àÌïòÍ≤å ÏÑ§Î™ÖÌï¥Ï£ºÏÑ∏Ïöî:\n\nÏõπÏÇ¨Ïù¥Ìä∏ Î∂ÑÏÑù Ï†êÏàò:\n- Ï†ÑÏ≤¥ ÌèâÍ∑†: ${overallAverage}Ï†ê\n- ÏÑ±Îä•: ${avgPerformance}Ï†ê\n- Ï†ëÍ∑ºÏÑ±: ${avgAccessibility}Ï†ê\n- SEO: ${avgSEO}Ï†ê\n\nÎ∞úÍ≤¨Îêú Ï£ºÏöî Î¨∏Ï†úÎì§:\n${issuesSummary}\n\nÎã§Ïùå ÌòïÏãùÏúºÎ°ú ÎãµÎ≥ÄÌï¥Ï£ºÏÑ∏Ïöî:\n1. Ï†ÑÏ≤¥Ï†ÅÏù∏ ÏÉÅÌô© ÏöîÏïΩ (2-3Î¨∏Ïû•)\n2. Í∞Å Ïπ¥ÌÖåÍ≥†Î¶¨Î≥Ñ Î¨∏Ï†úÏ†êÍ≥º Ìï¥Í≤∞ Î∞©Î≤ïÏùÑ ÏâΩÍ≤å ÏÑ§Î™Ö\n3. Ïö∞ÏÑ†ÏàúÏúÑÍ∞Ä ÎÜíÏùÄ Í∞úÏÑ†ÏÇ¨Ìï≠ 3Í∞ÄÏßÄ\n\nÏ†ÑÎ¨∏ Ïö©Ïñ¥Îäî ÌîºÌïòÍ≥†, ÏùºÎ∞òÏù∏ÎèÑ Ïù¥Ìï¥Ìï† Ïàò ÏûàÎäî Ïâ¨Ïö¥ ÎßêÎ°ú ÏÑ§Î™ÖÌï¥Ï£ºÏÑ∏Ïöî.`;
          const { GoogleGenerativeAI } = await import('@google/generative-ai');
          const genAI = new GoogleGenerativeAI(geminiApiKey);
          const model = genAI.getGenerativeModel({ model: 'gemini-2.5-flash' });
          const result = await model.generateContent({ contents: [{ role: 'user', parts: [{ text: prompt }] }] });
          const response = result?.response;
          const text = response ? await response.text() : '';
          aiExplanation = text || '(AI ÏÑ§Î™ÖÏùÑ ÏÉùÏÑ±ÌïòÏßÄ Î™ªÌñàÏäµÎãàÎã§)';
        } else {
          aiExplanation = '(AI ÏÑ§Î™ÖÏùÑ ÏÉùÏÑ±ÌïòÎ†§Î©¥ Google AI ÌÇ§Î•º Ï∂îÍ∞ÄÌïòÍ±∞ÎÇò GEMINI_API_KEY ÌôòÍ≤Ω Î≥ÄÏàòÎ•º ÏÑ§Ï†ïÌïòÏÑ∏Ïöî)';
        }
      } catch (aiError) {
        console.error('Failed to generate AI explanation:', aiError);
        aiExplanation = '(AI ÏÑ§Î™Ö ÏÉùÏÑ± Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§)';
      }

      const finalReportPath = path.join(outputDir, `final-seo-report-${Date.now()}.html`);
      const urlsCount = urls.length;
      const successfulCount = results.filter((r) => r.success).length;
      const failedCount = results.filter((r) => !r.success).length;

      const finalReportHtml = `<!DOCTYPE html><html lang="ko"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>SEO ÏµúÏ¢Ö Î∂ÑÏÑù Î≥¥Í≥†ÏÑú</title><style>*{margin:0;padding:0;box-sizing:border-box}body{font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,sans-serif;padding:40px;background:#f5f5f5}.container{max-width:1200px;margin:0 auto;background:#fff;padding:40px;border-radius:8px;box-shadow:0 2px 8px rgba(0,0,0,.1)}h1{color:#202124;margin-bottom:10px;font-size:32px}.subtitle{color:#5f6368;margin-bottom:40px;font-size:16px}.summary{display:grid;grid-template-columns:repeat(auto-fit,minmax(180px,1fr));gap:20px;margin-bottom:40px}.summary-card{padding:20px;border-radius:8px;background:#667eea;color:#fff}.summary-card .value{font-size:48px;font-weight:700;margin-bottom:8px}.summary-card .label{font-size:14px;opacity:.9}.overall-score{text-align:center;padding:40px;background:#f5576c;border-radius:12px;color:#fff;margin-bottom:40px}.overall-score .score{font-size:72px;font-weight:700;margin-bottom:10px}.overall-score .label{font-size:20px;opacity:.9}table{width:100%;border-collapse:collapse;margin-top:20px}th,td{padding:16px;text-align:left;border-bottom:1px solid #e0e0e0}th{background:#f8f9fa;font-weight:600;color:#202124}.score-badge{display:inline-block;padding:4px 12px;border-radius:12px;font-weight:600;font-size:14px;color:#fff}.url-cell{max-width:400px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.footer{margin-top:40px;padding-top:20px;border-top:1px solid #e0e0e0;color:#5f6368;font-size:14px;text-align:center}</style></head><body><div class="container"><h1>üéØ SEO ÏµúÏ¢Ö Î∂ÑÏÑù Î≥¥Í≥†ÏÑú</h1><div class="subtitle">ÏÉùÏÑ±Ïùº: ${new Date().toLocaleString('ko-KR')}</div><div class="overall-score"><div class="score">${overallAverage}</div><div class="label">Ï†ÑÏ≤¥ ÌèâÍ∑† Ï†êÏàò</div></div><div class="summary"><div class="summary-card"><div class="value">${avgPerformance}</div><div class="label">ÌèâÍ∑† ÏÑ±Îä•</div></div><div class="summary-card"><div class="value">${avgAccessibility}</div><div class="label">ÌèâÍ∑† Ï†ëÍ∑ºÏÑ±</div></div><div class="summary-card"><div class="value">${avgBestPractices}</div><div class="label">ÌèâÍ∑† Î™®Î≤î ÏÇ¨Î°Ä</div></div><div class="summary-card"><div class="value">${avgSEO}</div><div class="label">ÌèâÍ∑† SEO</div></div><div class="summary-card"><div class="value">${avgPWA}</div><div class="label">ÌèâÍ∑† PWA</div></div></div><h2 style="margin-bottom:20px;color:#202124;">ÌéòÏù¥ÏßÄÎ≥Ñ ÏÉÅÏÑ∏ Ï†êÏàò</h2><table><thead><tr><th>URL</th><th>ÏÑ±Îä•</th><th>Ï†ëÍ∑ºÏÑ±</th><th>Î™®Î≤î ÏÇ¨Î°Ä</th><th>SEO</th><th>PWA</th><th>ÌèâÍ∑†</th></tr></thead><tbody>${scores.map((s)=>`<tr><td class="url-cell" title="${s.url}">${s.url}</td><td><span class="score-badge" style="background-color:${getScoreColor(s.performance)}">${s.performance}</span></td><td><span class="score-badge" style="background-color:${getScoreColor(s.accessibility)}">${s.accessibility}</span></td><td><span class="score-badge" style="background-color:${getScoreColor(s.bestPractices)}">${s.bestPractices}</span></td><td><span class="score-badge" style="background-color:${getScoreColor(s.seo)}">${s.seo}</span></td><td><span class="score-badge" style="background-color:${getScoreColor(s.pwa)}">${s.pwa}</span></td><td><span class="score-badge" style="background-color:${getScoreColor(s.average)}">${s.average}</span></td></tr>`).join('')}</tbody></table><div class="footer"><p>Ï¥ù ${urlsCount}Í∞ú ÌéòÏù¥ÏßÄ Î∂ÑÏÑù ÏôÑÎ£å (ÏÑ±Í≥µ: ${successfulCount}Í∞ú, Ïã§Ìå®: ${failedCount}Í∞ú)</p><p>ÏÉÅÏÑ∏ Î≥¥Í≥†ÏÑúÎäî Í∞úÎ≥Ñ Lighthouse HTML ÌååÏùºÏùÑ Ï∞∏Ï°∞ÌïòÏÑ∏Ïöî.</p></div></div></body></html>`;
      fs.writeFileSync(finalReportPath, finalReportHtml);

      await browser.close();

      return {
        success: true,
        results,
        summary: { total: urls.length, successful: successfulCount, failed: failedCount },
        mergedJsonPath,
        mergedPdfPath: null,
        finalReportPath,
        scores: {
          overall: overallAverage,
          performance: avgPerformance,
          accessibility: avgAccessibility,
          bestPractices: avgBestPractices,
          seo: avgSEO,
          pwa: avgPWA,
        },
      };
    } catch (error: any) {
      console.error('‚ùå Batch Lighthouse generation failed:', error);
      return { success: false, error: error?.message || 'Unknown error' };
    }
  });
}


