/**
 * Apps Script Sync Injector
 *
 * Automatically injects sync endpoint logic into Apps Script projects
 * when they are created or copied. This sets up bidirectional sync
 * between Google Sheets and SQLite.
 */

import { AppsScriptService } from '../apps-script/apps-script-service';

export interface SyncInjectionConfig {
  tunnelUrl?: string;
  syncMode?: 'manual' | 'periodic' | 'realtime';
  periodicIntervalMs?: number;
}

export interface SyncInjectionResult {
  success: boolean;
  filesCreated: string[];
  triggersSetup: string[];
  message: string;
  error?: string;
}

/**
 * Apps Script Sync Injector
 * Injects sync logic into Apps Script projects
 */
export class AppsScriptSyncInjector {
  private appsScriptService: AppsScriptService;

  constructor(appsScriptService: AppsScriptService) {
    this.appsScriptService = appsScriptService;
  }

  /**
   * Inject sync endpoints into an Apps Script project
   * @param projectId - The Apps Script project ID
   * @param config - Sync configuration
   */
  async injectSyncEndpoints(
    projectId: string,
    config: SyncInjectionConfig = {}
  ): Promise<SyncInjectionResult> {
    const filesCreated: string[] = [];
    const triggersSetup: string[] = [];

    try {
      console.log(`[SyncInjector] Injecting sync endpoints into project: ${projectId}`);

      // 1. Create the sync code file
      await this.createSyncCodeFile(projectId, config);
      filesCreated.push('SyncEndpoints.gs');

      // 2. Create the changelog manager file
      await this.createChangelogManagerFile(projectId);
      filesCreated.push('ChangelogManager.gs');

      // 3. Create the configuration file
      await this.createConfigFile(projectId, config);
      filesCreated.push('SyncConfig.gs');

      // 4. Update appsscript.json manifest
      await this.updateManifest(projectId);
      filesCreated.push('appsscript.json (updated)');

      // 5. Set up triggers (onEdit)
      await this.setupTriggers(projectId);
      triggersSetup.push('onEdit', 'doPost (webhook)');

      console.log(`[SyncInjector] Successfully injected sync endpoints`);

      return {
        success: true,
        filesCreated,
        triggersSetup,
        message: `Successfully injected sync endpoints. Created ${filesCreated.length} files and set up ${triggersSetup.length} triggers.`,
      };
    } catch (error) {
      console.error(`[SyncInjector] Failed to inject sync endpoints:`, error);
      return {
        success: false,
        filesCreated,
        triggersSetup,
        message: 'Failed to inject sync endpoints',
        error: error instanceof Error ? error.message : String(error),
      };
    }
  }

  /**
   * Create the main sync code file
   */
  private async createSyncCodeFile(
    projectId: string,
    config: SyncInjectionConfig
  ): Promise<void> {
    const code = this.generateSyncCode(config);
    await this.appsScriptService.writeFile(`${projectId}/SyncEndpoints.gs`, code);
  }

  /**
   * Generate the sync endpoint code
   */
  private generateSyncCode(config: SyncInjectionConfig): string {
    return `/**
 * Auto-generated Sync Endpoints
 * Generated by EGDesk Apps Script Sync Injector
 *
 * This file provides bidirectional sync between Google Sheets and SQLite.
 */

// =============================================================================
// Configuration
// =============================================================================

var SYNC_CONFIG = {
  mode: '${config.syncMode || 'manual'}',
  tunnelUrl: '${config.tunnelUrl || ''}',
  periodicIntervalMs: ${config.periodicIntervalMs || 60000},
};

// =============================================================================
// Changelog Tracking (Sheet → SQLite)
// =============================================================================

/**
 * onEdit trigger - automatically tracks cell changes
 * This is installed as a simple trigger
 */
function onEdit(e) {
  if (!e || !e.range) return;

  try {
    var sheet = e.range.getSheet();
    var row = e.range.getRow();
    var col = e.range.getColumn();
    var oldValue = e.oldValue || '';
    var newValue = e.value || '';

    // Skip header row (row 1)
    if (row === 1) {
      Logger.log('Header row changed, not tracking');
      return;
    }

    // Track the change
    ChangelogManager.trackChange({
      sheet: sheet.getName(),
      row: row,
      col: col,
      oldValue: oldValue,
      newValue: newValue,
      source: 'edit',
      timestamp: new Date().toISOString()
    });

    // If realtime mode, push immediately
    if (SYNC_CONFIG.mode === 'realtime' && SYNC_CONFIG.tunnelUrl) {
      pushChangesNow();
    }
  } catch (error) {
    Logger.log('Error in onEdit: ' + error.toString());
  }
}

/**
 * Get unsynced changes
 * Called by SQLite client to pull changes
 */
function getUnsynced() {
  try {
    return ChangelogManager.getUnsyncedChanges();
  } catch (error) {
    Logger.log('Error getting unsynced changes: ' + error.toString());
    return [];
  }
}

/**
 * Mark changes as synced
 * Called by SQLite client after processing changes
 */
function markSynced(changeIds) {
  try {
    ChangelogManager.markAsSynced(changeIds);
    return { success: true, count: changeIds.length };
  } catch (error) {
    Logger.log('Error marking changes as synced: ' + error.toString());
    return { success: false, error: error.toString() };
  }
}

/**
 * Get column headers for a sheet
 * Used by SQLite client to map columns
 */
function getColumnHeaders(sheetName) {
  try {
    var ss = SpreadsheetApp.getActiveSpreadsheet();
    var sheet = ss.getSheetByName(sheetName);

    if (!sheet) {
      return [];
    }

    var headerRow = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
    var headers = [];

    for (var i = 0; i < headerRow.length; i++) {
      headers.push({
        index: i + 1, // 1-based
        header: String(headerRow[i] || '')
      });
    }

    return headers;
  } catch (error) {
    Logger.log('Error getting column headers: ' + error.toString());
    return [];
  }
}

// =============================================================================
// Push Updates (SQLite → Sheet)
// =============================================================================

/**
 * Batch update cells from SQLite
 * Called by SQLite client to push local changes to sheet
 */
function batchUpdateCells(updates) {
  try {
    var ss = SpreadsheetApp.getActiveSpreadsheet();
    var updateCount = 0;

    // Group updates by sheet for efficiency
    var updatesBySheet = {};
    for (var i = 0; i < updates.length; i++) {
      var update = updates[i];
      if (!updatesBySheet[update.sheet]) {
        updatesBySheet[update.sheet] = [];
      }
      updatesBySheet[update.sheet].push(update);
    }

    // Apply updates
    for (var sheetName in updatesBySheet) {
      var sheet = ss.getSheetByName(sheetName);
      if (!sheet) {
        Logger.log('Sheet not found: ' + sheetName);
        continue;
      }

      var sheetUpdates = updatesBySheet[sheetName];
      for (var j = 0; j < sheetUpdates.length; j++) {
        var update = sheetUpdates[j];
        var cell = sheet.getRange(update.row, update.col);
        cell.setValue(update.value);
        updateCount++;
      }
    }

    return { success: true, updated: updateCount };
  } catch (error) {
    Logger.log('Error in batchUpdateCells: ' + error.toString());
    return { success: false, error: error.toString() };
  }
}

// =============================================================================
// Configuration Management
// =============================================================================

/**
 * Set sync mode
 * Called by SQLite client to change sync behavior
 */
function setSyncMode(mode) {
  try {
    if (!['manual', 'periodic', 'realtime'].includes(mode)) {
      throw new Error('Invalid sync mode: ' + mode);
    }

    SYNC_CONFIG.mode = mode;
    PropertiesService.getScriptProperties().setProperty('syncMode', mode);

    // Set up periodic trigger if needed
    if (mode === 'periodic') {
      setupPeriodicSync();
    } else {
      // Clear periodic triggers
      clearPeriodicSync();
    }

    return { success: true, mode: mode };
  } catch (error) {
    Logger.log('Error setting sync mode: ' + error.toString());
    return { success: false, error: error.toString() };
  }
}

/**
 * Set tunnel URL
 * Called by SQLite client to configure webhook endpoint
 */
function setTunnelUrl(url) {
  try {
    SYNC_CONFIG.tunnelUrl = url;
    PropertiesService.getScriptProperties().setProperty('tunnelUrl', url);
    return { success: true, url: url };
  } catch (error) {
    Logger.log('Error setting tunnel URL: ' + error.toString());
    return { success: false, error: error.toString() };
  }
}

/**
 * Get current configuration
 */
function getConfig() {
  try {
    var props = PropertiesService.getScriptProperties();
    return {
      mode: props.getProperty('syncMode') || SYNC_CONFIG.mode,
      tunnelUrl: props.getProperty('tunnelUrl') || SYNC_CONFIG.tunnelUrl,
      periodicIntervalMs: SYNC_CONFIG.periodicIntervalMs
    };
  } catch (error) {
    Logger.log('Error getting config: ' + error.toString());
    return SYNC_CONFIG;
  }
}

// =============================================================================
// Webhook Handler (for realtime mode)
// =============================================================================

/**
 * doPost - handles HTTP POST requests for realtime webhooks
 * This receives commands from SQLite client via tunnel
 */
function doPost(e) {
  try {
    if (!e || !e.postData) {
      return ContentService.createTextOutput(JSON.stringify({
        success: false,
        error: 'No post data'
      })).setMimeType(ContentService.MimeType.JSON);
    }

    var data = JSON.parse(e.postData.contents);
    var command = data.command;
    var params = data.params || {};

    var result;
    switch (command) {
      case 'getUnsynced':
        result = getUnsynced();
        break;
      case 'markSynced':
        result = markSynced(params.changeIds);
        break;
      case 'batchUpdateCells':
        result = batchUpdateCells(params.updates);
        break;
      case 'getColumnHeaders':
        result = getColumnHeaders(params.sheetName);
        break;
      default:
        result = { success: false, error: 'Unknown command: ' + command };
    }

    return ContentService.createTextOutput(JSON.stringify(result))
      .setMimeType(ContentService.MimeType.JSON);
  } catch (error) {
    Logger.log('Error in doPost: ' + error.toString());
    return ContentService.createTextOutput(JSON.stringify({
      success: false,
      error: error.toString()
    })).setMimeType(ContentService.MimeType.JSON);
  }
}

// =============================================================================
// Periodic Sync (for periodic mode)
// =============================================================================

/**
 * Periodic sync function
 * Runs on a timer to push changes to SQLite
 */
function periodicSync() {
  try {
    if (SYNC_CONFIG.mode !== 'periodic') {
      return;
    }

    pushChangesNow();
  } catch (error) {
    Logger.log('Error in periodicSync: ' + error.toString());
  }
}

/**
 * Push changes immediately to tunnel
 */
function pushChangesNow() {
  try {
    var config = getConfig();
    if (!config.tunnelUrl) {
      Logger.log('No tunnel URL configured, cannot push changes');
      return;
    }

    var changes = ChangelogManager.getUnsyncedChanges();
    if (changes.length === 0) {
      Logger.log('No changes to push');
      return;
    }

    var response = UrlFetchApp.fetch(config.tunnelUrl + '/sync/push', {
      method: 'post',
      contentType: 'application/json',
      payload: JSON.stringify({ changes: changes }),
      muteHttpExceptions: true
    });

    if (response.getResponseCode() === 200) {
      var result = JSON.parse(response.getContentText());
      if (result.success) {
        // Mark changes as synced
        var changeIds = changes.map(function(c) { return c.id; });
        ChangelogManager.markAsSynced(changeIds);
        Logger.log('Pushed ' + changes.length + ' changes');
      }
    } else {
      Logger.log('Failed to push changes: ' + response.getResponseCode());
    }
  } catch (error) {
    Logger.log('Error pushing changes: ' + error.toString());
  }
}

/**
 * Set up periodic sync trigger
 */
function setupPeriodicSync() {
  try {
    // Clear existing triggers
    clearPeriodicSync();

    // Create new time-based trigger (every 1 minute)
    ScriptApp.newTrigger('periodicSync')
      .timeBased()
      .everyMinutes(1)
      .create();

    Logger.log('Periodic sync trigger created');
  } catch (error) {
    Logger.log('Error setting up periodic sync: ' + error.toString());
  }
}

/**
 * Clear periodic sync triggers
 */
function clearPeriodicSync() {
  try {
    var triggers = ScriptApp.getProjectTriggers();
    for (var i = 0; i < triggers.length; i++) {
      if (triggers[i].getHandlerFunction() === 'periodicSync') {
        ScriptApp.deleteTrigger(triggers[i]);
      }
    }
    Logger.log('Cleared periodic sync triggers');
  } catch (error) {
    Logger.log('Error clearing periodic sync: ' + error.toString());
  }
}

// =============================================================================
// Utility Functions
// =============================================================================

/**
 * Test function to verify sync is working
 */
function testSync() {
  Logger.log('=== Sync Endpoint Test ===');

  // Test 1: Get config
  Logger.log('Config: ' + JSON.stringify(getConfig()));

  // Test 2: Get unsynced changes
  var changes = getUnsynced();
  Logger.log('Unsynced changes: ' + changes.length);

  // Test 3: Get column headers
  var ss = SpreadsheetApp.getActiveSpreadsheet();
  var sheetName = ss.getSheets()[0].getName();
  var headers = getColumnHeaders(sheetName);
  Logger.log('Headers for ' + sheetName + ': ' + JSON.stringify(headers));

  Logger.log('=== Test Complete ===');
}
`;
  }

  /**
   * Create the changelog manager file
   */
  private async createChangelogManagerFile(projectId: string): Promise<void> {
    const code = `/**
 * Changelog Manager
 * Manages the changelog of cell edits for sync
 */

var ChangelogManager = (function() {
  var CHANGELOG_SHEET_NAME = '_sync_changelog';
  var MAX_CHANGELOG_SIZE = 10000;

  /**
   * Get or create the changelog sheet
   */
  function getChangelogSheet() {
    var ss = SpreadsheetApp.getActiveSpreadsheet();
    var sheet = ss.getSheetByName(CHANGELOG_SHEET_NAME);

    if (!sheet) {
      sheet = ss.insertSheet(CHANGELOG_SHEET_NAME);
      sheet.setHiddenGridlines(true);
      sheet.hideSheet();

      // Set up headers
      sheet.getRange(1, 1, 1, 8).setValues([[
        'ID', 'Sheet', 'Row', 'Col', 'Old Value', 'New Value', 'Timestamp', 'Synced'
      ]]);
      sheet.getRange(1, 1, 1, 8).setFontWeight('bold');
    }

    return sheet;
  }

  /**
   * Track a cell change
   */
  function trackChange(change) {
    try {
      var sheet = getChangelogSheet();
      var id = Utilities.getUuid();

      // Add new row
      sheet.appendRow([
        id,
        change.sheet,
        change.row,
        change.col,
        change.oldValue,
        change.newValue,
        change.timestamp,
        'no'
      ]);

      // Cleanup old entries if needed
      cleanupOldEntries(sheet);

      return id;
    } catch (error) {
      Logger.log('Error tracking change: ' + error.toString());
      return null;
    }
  }

  /**
   * Get unsynced changes
   */
  function getUnsyncedChanges() {
    try {
      var sheet = getChangelogSheet();
      var lastRow = sheet.getLastRow();

      if (lastRow <= 1) return [];

      var data = sheet.getRange(2, 1, lastRow - 1, 8).getValues();
      var changes = [];

      for (var i = 0; i < data.length; i++) {
        if (data[i][7] === 'no') { // Not synced
          changes.push({
            id: data[i][0],
            sheet: data[i][1],
            row: data[i][2],
            col: data[i][3],
            oldValue: data[i][4],
            newValue: data[i][5],
            timestamp: data[i][6],
            source: 'edit'
          });
        }
      }

      return changes;
    } catch (error) {
      Logger.log('Error getting unsynced changes: ' + error.toString());
      return [];
    }
  }

  /**
   * Mark changes as synced
   */
  function markAsSynced(changeIds) {
    try {
      var sheet = getChangelogSheet();
      var lastRow = sheet.getLastRow();

      if (lastRow <= 1) return;

      var data = sheet.getRange(2, 1, lastRow - 1, 8).getValues();
      var updates = [];

      for (var i = 0; i < data.length; i++) {
        if (changeIds.indexOf(data[i][0]) !== -1) {
          updates.push([i + 2, 8, 'yes']); // Row, Column, Value
        }
      }

      // Batch update
      for (var j = 0; j < updates.length; j++) {
        sheet.getRange(updates[j][0], updates[j][1]).setValue(updates[j][2]);
      }

      return updates.length;
    } catch (error) {
      Logger.log('Error marking changes as synced: ' + error.toString());
      return 0;
    }
  }

  /**
   * Cleanup old synced entries
   */
  function cleanupOldEntries(sheet) {
    try {
      var lastRow = sheet.getLastRow();

      if (lastRow <= MAX_CHANGELOG_SIZE) return;

      // Find synced rows
      var data = sheet.getRange(2, 1, lastRow - 1, 8).getValues();
      var rowsToDelete = [];

      for (var i = 0; i < data.length; i++) {
        if (data[i][7] === 'yes') { // Synced
          rowsToDelete.push(i + 2); // Actual row number
        }

        // Stop when we've found enough to delete
        if (rowsToDelete.length >= lastRow - MAX_CHANGELOG_SIZE) {
          break;
        }
      }

      // Delete from bottom to top to avoid row number changes
      rowsToDelete.reverse();
      for (var j = 0; j < rowsToDelete.length; j++) {
        sheet.deleteRow(rowsToDelete[j]);
      }

      Logger.log('Cleaned up ' + rowsToDelete.length + ' old changelog entries');
    } catch (error) {
      Logger.log('Error cleaning up changelog: ' + error.toString());
    }
  }

  /**
   * Clear all changelog entries
   */
  function clearChangelog() {
    try {
      var sheet = getChangelogSheet();
      var lastRow = sheet.getLastRow();

      if (lastRow > 1) {
        sheet.deleteRows(2, lastRow - 1);
      }

      Logger.log('Cleared changelog');
    } catch (error) {
      Logger.log('Error clearing changelog: ' + error.toString());
    }
  }

  // Public API
  return {
    trackChange: trackChange,
    getUnsyncedChanges: getUnsyncedChanges,
    markAsSynced: markAsSynced,
    clearChangelog: clearChangelog
  };
})();
`;

    await this.appsScriptService.writeFile(`${projectId}/ChangelogManager.gs`, code);
  }

  /**
   * Create the configuration file
   */
  private async createConfigFile(
    projectId: string,
    config: SyncInjectionConfig
  ): Promise<void> {
    const code = `/**
 * Sync Configuration
 * Configuration values for sync endpoints
 */

// Default configuration
var DEFAULT_CONFIG = {
  mode: '${config.syncMode || 'manual'}',
  tunnelUrl: '${config.tunnelUrl || ''}',
  periodicIntervalMs: ${config.periodicIntervalMs || 60000}
};

/**
 * Get configuration value
 */
function getConfigValue(key) {
  var props = PropertiesService.getScriptProperties();
  var value = props.getProperty(key);
  return value || DEFAULT_CONFIG[key];
}

/**
 * Set configuration value
 */
function setConfigValue(key, value) {
  var props = PropertiesService.getScriptProperties();
  props.setProperty(key, String(value));
}

/**
 * Get all configuration
 */
function getAllConfig() {
  return {
    mode: getConfigValue('mode'),
    tunnelUrl: getConfigValue('tunnelUrl'),
    periodicIntervalMs: getConfigValue('periodicIntervalMs')
  };
}
`;

    await this.appsScriptService.writeFile(`${projectId}/SyncConfig.gs`, code);
  }

  /**
   * Update the manifest file to include necessary permissions
   */
  private async updateManifest(projectId: string): Promise<void> {
    try {
      // Read existing manifest
      let manifest: any;
      try {
        const manifestContent = await this.appsScriptService.readFile(`${projectId}/appsscript.json`);
        manifest = JSON.parse(manifestContent);
      } catch (error) {
        // Create new manifest if doesn't exist
        manifest = {
          timeZone: 'America/New_York',
          exceptionLogging: 'STACKDRIVER',
          runtimeVersion: 'V8'
        };
      }

      // Ensure required OAuth scopes
      if (!manifest.oauthScopes) {
        manifest.oauthScopes = [];
      }

      const requiredScopes = [
        'https://www.googleapis.com/auth/spreadsheets',
        'https://www.googleapis.com/auth/script.external_request',
        'https://www.googleapis.com/auth/script.scriptapp'
      ];

      for (const scope of requiredScopes) {
        if (!manifest.oauthScopes.includes(scope)) {
          manifest.oauthScopes.push(scope);
        }
      }

      // Enable webapp if not already
      if (!manifest.webapp) {
        manifest.webapp = {
          access: 'ANYONE_ANONYMOUS',
          executeAs: 'USER_DEPLOYING'
        };
      }

      // Write updated manifest
      await this.appsScriptService.writeFile(
        `${projectId}/appsscript.json`,
        JSON.stringify(manifest, null, 2)
      );
    } catch (error) {
      console.error('[SyncInjector] Failed to update manifest:', error);
      throw error;
    }
  }

  /**
   * Set up necessary triggers for sync
   */
  private async setupTriggers(projectId: string): Promise<void> {
    try {
      // The onEdit trigger is automatically installed as a simple trigger
      // when the function exists in the script

      // For installable triggers (like time-based), we need to use the API
      // But for simple triggers (onEdit, onOpen), they're automatically active

      console.log('[SyncInjector] Triggers will be automatically active when functions are present');
    } catch (error) {
      console.error('[SyncInjector] Failed to setup triggers:', error);
      throw error;
    }
  }

  /**
   * Check if a project already has sync endpoints
   */
  async hasSyncEndpoints(projectId: string): Promise<boolean> {
    try {
      const files = await this.appsScriptService.listDirectory(projectId);

      // Check if SyncEndpoints.gs exists
      const hasSyncEndpoints = files.some((file: any) => {
        const fileName = typeof file === 'string' ? file : file.name;
        return fileName === 'SyncEndpoints.gs';
      });

      return hasSyncEndpoints;
    } catch (error) {
      console.error('[SyncInjector] Failed to check for sync endpoints:', error);
      return false;
    }
  }

  /**
   * Remove sync endpoints from a project
   */
  async removeSyncEndpoints(projectId: string): Promise<SyncInjectionResult> {
    const filesRemoved: string[] = [];

    try {
      console.log(`[SyncInjector] Removing sync endpoints from project: ${projectId}`);

      const filesToRemove = [
        'SyncEndpoints.gs',
        'ChangelogManager.gs',
        'SyncConfig.gs'
      ];

      for (const file of filesToRemove) {
        try {
          await this.appsScriptService.deleteFile(`${projectId}/${file}`);
          filesRemoved.push(file);
        } catch (error) {
          // File might not exist, continue
          console.log(`[SyncInjector] Could not remove ${file}:`, error);
        }
      }

      return {
        success: true,
        filesCreated: filesRemoved,
        triggersSetup: [],
        message: `Removed ${filesRemoved.length} sync files`,
      };
    } catch (error) {
      console.error(`[SyncInjector] Failed to remove sync endpoints:`, error);
      return {
        success: false,
        filesCreated: filesRemoved,
        triggersSetup: [],
        message: 'Failed to remove sync endpoints',
        error: error instanceof Error ? error.message : String(error),
      };
    }
  }
}

/**
 * Factory function to create a sync injector
 */
export function createSyncInjector(appsScriptService: AppsScriptService): AppsScriptSyncInjector {
  return new AppsScriptSyncInjector(appsScriptService);
}
