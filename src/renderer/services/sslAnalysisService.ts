/**
 * SSL Analysis Service
 * Implements the first step of SSL analysis: Website accessibility and SSL availability checking
 * Based on the SSL_Analyzer.md specification
 */

export interface WebsiteAccessibilityResult {
  accessible: boolean;
  hasSSL: boolean;
  connectionDetails?: {
    hostname: string;
    port: number;
    connectionTime: number;
    protocol?: string;
  };
  error?: string;
  timestamp: string;
}

export interface CertificateInfo {
  subject: string;
  issuer: string;
  validFrom: string;
  validTo: string;
  serialNumber: string;
  fingerprint: string;
  isExpired: boolean;
  isSelfSigned: boolean;
  isValid: boolean;
  daysUntilExpiry: number;
  error?: string;
}

export interface SSLCertificateResult {
  certificateInfo?: CertificateInfo;
  certificateStatus: 'valid' | 'expired' | 'self-signed' | 'invalid' | 'error';
  error?: string;
  timestamp: string;
}

export interface SecurityHeader {
  name: string;
  value: string;
  present: boolean;
  recommended: boolean;
  description: string;
}

export interface SecurityHeadersResult {
  headers: SecurityHeader[];
  missingHeaders: string[];
  securityScore: number;
  recommendations: string[];
  error?: string;
  timestamp: string;
}

export interface SecurityGrade {
  grade: 'A+' | 'A' | 'B' | 'C' | 'D' | 'F';
  score: number;
  description: string;
  criticalIssues: string[];
  highIssues: string[];
  mediumIssues: string[];
  lowIssues: string[];
}

export interface BusinessImpactResult {
  monthlyVisitors: number;
  conversionRate: number;
  orderConversionRate: number;
  averageOrderValue: number;
  securityLossRate: number;
  annualLoss: number;
  seoRankingLoss: number;
  customerTrustLoss: number;
  brandImageImpact: string;
  roi: number;
  investmentCost: number;
  netBenefit: number;
  report: string;
}

export interface OverallSecurityResult {
  grade: SecurityGrade;
  accessibility: WebsiteAccessibilityResult;
  certificate: SSLCertificateResult;
  securityHeaders: SecurityHeadersResult;
  businessImpact: BusinessImpactResult;
  combinedReport: string;
  timestamp: string;
}

export class SSLAnalysisService {
  /**
   * Step 1: Check website accessibility and SSL availability
   * Tests if the website is accessible and has SSL on port 443
   */
  static async analyzeWebsiteAccessibility(url: string): Promise<WebsiteAccessibilityResult> {
    const startTime = Date.now();
    const timestamp = new Date().toISOString();
    
    try {
      // Normalize URL - ensure it has protocol
      const normalizedUrl = this.normalizeUrl(url);
      const urlObj = new URL(normalizedUrl);
      
      // Check if it's HTTPS
      if (urlObj.protocol !== 'https:') {
        return {
          accessible: false,
          hasSSL: false,
          error: 'URL must use HTTPS protocol',
          timestamp
        };
      }

      // Test connection to port 443 (HTTPS)
      const connectionResult = await this.testHttpsConnection(urlObj.hostname, 443);
      
      if (connectionResult.success) {
        return {
          accessible: true,
          hasSSL: true,
          connectionDetails: {
            hostname: urlObj.hostname,
            port: 443,
            connectionTime: Date.now() - startTime,
            protocol: 'HTTPS'
          },
          timestamp
        };
      } else {
        return {
          accessible: false,
          hasSSL: false,
          connectionDetails: {
            hostname: urlObj.hostname,
            port: 443,
            connectionTime: Date.now() - startTime
          },
          error: connectionResult.error || 'Connection failed',
          timestamp
        };
      }
    } catch (error) {
      return {
        accessible: false,
        hasSSL: false,
        error: error instanceof Error ? error.message : 'Unknown error occurred',
        timestamp
      };
    }
  }

  /**
   * Normalize URL to ensure it has proper protocol
   */
  private static normalizeUrl(url: string): string {
    // Remove any whitespace
    url = url.trim();
    
    // If no protocol specified, assume HTTPS
    if (!url.startsWith('http://') && !url.startsWith('https://')) {
      url = 'https://' + url;
    }
    
    return url;
  }

  /**
   * Test HTTPS connection to a specific host and port
   * This is a simplified version that uses fetch API
   */
  private static async testHttpsConnection(hostname: string, port: number): Promise<{success: boolean, error?: string}> {
    try {
      const testUrl = `https://${hostname}:${port}`;
      
      // Use fetch with a timeout to test the connection
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 second timeout
      
      const response = await fetch(testUrl, {
        method: 'HEAD',
        signal: controller.signal,
        mode: 'no-cors' // This allows us to test connectivity even with CORS issues
      });
      
      clearTimeout(timeoutId);
      
      // If we get here, the connection was successful
      return { success: true };
    } catch (error) {
      if (error instanceof Error) {
        if (error.name === 'AbortError') {
          return { success: false, error: 'Connection timeout' };
        }
        return { success: false, error: error.message };
      }
      return { success: false, error: 'Connection failed' };
    }
  }

  /**
   * Step 2: Analyze SSL Certificate Status
   * Checks if the SSL certificate is valid, expired, or self-signed
   */
  static async analyzeSSLCertificate(url: string): Promise<SSLCertificateResult> {
    const timestamp = new Date().toISOString();
    
    try {
      // First check if the website is accessible
      const accessibilityResult = await this.analyzeWebsiteAccessibility(url);
      
      if (!accessibilityResult.accessible || !accessibilityResult.hasSSL) {
        return {
          certificateStatus: 'error',
          error: 'Website is not accessible or does not have SSL',
          timestamp
        };
      }

      // Get certificate information
      const certificateInfo = await this.getCertificateInfo(url);
      
      if (certificateInfo.error) {
        return {
          certificateStatus: 'error',
          error: certificateInfo.error,
          timestamp
        };
      }

      // Determine certificate status
      let certificateStatus: 'valid' | 'expired' | 'self-signed' | 'invalid' | 'error';
      
      if (certificateInfo.isExpired) {
        certificateStatus = 'expired';
      } else if (certificateInfo.isSelfSigned) {
        certificateStatus = 'self-signed';
      } else if (certificateInfo.isValid) {
        certificateStatus = 'valid';
      } else {
        certificateStatus = 'invalid';
      }

      return {
        certificateInfo,
        certificateStatus,
        timestamp
      };
    } catch (error) {
      return {
        certificateStatus: 'error',
        error: error instanceof Error ? error.message : 'Unknown error occurred',
        timestamp
      };
    }
  }

  /**
   * Get certificate information from a website
   * Note: This is a simplified implementation using fetch API
   * In a real implementation, you would use Node.js crypto module or similar
   */
  private static async getCertificateInfo(url: string): Promise<CertificateInfo> {
    try {
      const normalizedUrl = this.normalizeUrl(url);
      const urlObj = new URL(normalizedUrl);
      
      // For browser environment, we can't directly access certificate details
      // This is a limitation of the browser security model
      // In a real implementation, this would be done server-side using Node.js
      
      // Simulate certificate analysis for demo purposes
      const now = new Date();
      const validFrom = new Date(now.getTime() - 365 * 24 * 60 * 60 * 1000); // 1 year ago
      const validTo = new Date(now.getTime() + 30 * 24 * 60 * 60 * 1000); // 30 days from now
      
      const isExpired = now > validTo;
      const daysUntilExpiry = Math.ceil((validTo.getTime() - now.getTime()) / (1000 * 60 * 60 * 24));
      
      // Simulate different certificate types based on domain
      const isSelfSigned = urlObj.hostname.includes('localhost') || urlObj.hostname.includes('127.0.0.1');
      const isValid = !isExpired && !isSelfSigned;
      
      return {
        subject: `CN=${urlObj.hostname}`,
        issuer: isSelfSigned ? 'Self-signed' : 'Let\'s Encrypt Authority X3',
        validFrom: validFrom.toISOString(),
        validTo: validTo.toISOString(),
        serialNumber: '1234567890ABCDEF',
        fingerprint: 'SHA256:ABCDEF1234567890',
        isExpired,
        isSelfSigned,
        isValid,
        daysUntilExpiry: Math.max(0, daysUntilExpiry)
      };
    } catch (error) {
      return {
        subject: '',
        issuer: '',
        validFrom: '',
        validTo: '',
        serialNumber: '',
        fingerprint: '',
        isExpired: false,
        isSelfSigned: false,
        isValid: false,
        daysUntilExpiry: 0,
        error: error instanceof Error ? error.message : 'Failed to get certificate info'
      };
    }
  }

  /**
   * Generate a human-readable report from the accessibility analysis
   */
  static generateAccessibilityReport(result: WebsiteAccessibilityResult): string {
    let report = `üîç SSL Î∂ÑÏÑù Î≥¥Í≥†ÏÑú\n`;
    report += `üìÖ ÏÉùÏÑ±Ïùº: ${new Date(result.timestamp).toLocaleString()}\n\n`;
    
    if (result.accessible && result.hasSSL) {
      report += `‚úÖ ÏõπÏÇ¨Ïù¥Ìä∏ ÏÉÅÌÉú: Ï†ëÍ∑º Í∞ÄÎä•\n`;
      report += `üîí SSL ÏÉÅÌÉú: ÏÇ¨Ïö© Í∞ÄÎä•\n`;
      
      if (result.connectionDetails) {
        report += `\nüìä Ïó∞Í≤∞ ÏÉÅÏÑ∏ Ï†ïÎ≥¥:\n`;
        report += `   ‚Ä¢ Ìò∏Ïä§Ìä∏Î™Ö: ${result.connectionDetails.hostname}\n`;
        report += `   ‚Ä¢ Ìè¨Ìä∏: ${result.connectionDetails.port}\n`;
        report += `   ‚Ä¢ Ïó∞Í≤∞ ÏãúÍ∞Ñ: ${result.connectionDetails.connectionTime}ms\n`;
        report += `   ‚Ä¢ ÌîÑÎ°úÌÜ†ÏΩú: ${result.connectionDetails.protocol || 'HTTPS'}\n`;
      }
      
      report += `\nüéØ Îã§Ïùå Îã®Í≥Ñ: SSL Ïù∏Ï¶ùÏÑú Î∂ÑÏÑù Ï§ÄÎπÑ ÏôÑÎ£å\n`;
    } else {
      report += `‚ùå ÏõπÏÇ¨Ïù¥Ìä∏ ÏÉÅÌÉú: Ï†ëÍ∑º Î∂àÍ∞Ä\n`;
      report += `üîí SSL ÏÉÅÌÉú: ${result.hasSSL ? 'ÏÇ¨Ïö© Í∞ÄÎä•' : 'ÏÇ¨Ïö© Î∂àÍ∞Ä'}\n`;
      
      if (result.error) {
        report += `\n‚ö†Ô∏è Ïò§Î•ò ÏÉÅÏÑ∏ Ï†ïÎ≥¥:\n`;
        report += `   ${result.error}\n`;
      }
      
      if (result.connectionDetails) {
        report += `\nüìä Ïó∞Í≤∞ ÏÉÅÏÑ∏ Ï†ïÎ≥¥:\n`;
        report += `   ‚Ä¢ Ìò∏Ïä§Ìä∏Î™Ö: ${result.connectionDetails.hostname}\n`;
        report += `   ‚Ä¢ Ìè¨Ìä∏: ${result.connectionDetails.port}\n`;
        report += `   ‚Ä¢ Ïó∞Í≤∞ ÏãúÍ∞Ñ: ${result.connectionDetails.connectionTime}ms\n`;
      }
      
      report += `\nüö´ SSL Î∂ÑÏÑùÏùÑ ÏßÑÌñâÌï† Ïàò ÏóÜÏäµÎãàÎã§ - ÏõπÏÇ¨Ïù¥Ìä∏Ïóê Ï†ëÍ∑ºÌï† Ïàò ÏóÜÏäµÎãàÎã§\n`;
    }
    
    return report;
  }

  /**
   * Generate a human-readable report from the certificate analysis
   */
  static generateCertificateReport(result: SSLCertificateResult): string {
    let report = `üîí SSL Ïù∏Ï¶ùÏÑú Î∂ÑÏÑù Î≥¥Í≥†ÏÑú\n`;
    report += `üìÖ ÏÉùÏÑ±Ïùº: ${new Date(result.timestamp).toLocaleString()}\n\n`;
    
    if (result.certificateInfo) {
      const cert = result.certificateInfo;
      
      report += `üìã Ïù∏Ï¶ùÏÑú ÏÉÅÏÑ∏ Ï†ïÎ≥¥:\n`;
      report += `   ‚Ä¢ Ï£ºÏ≤¥: ${cert.subject}\n`;
      report += `   ‚Ä¢ Î∞úÍ∏âÏûê: ${cert.issuer}\n`;
      report += `   ‚Ä¢ Ïú†Ìö® ÏãúÏûëÏùº: ${new Date(cert.validFrom).toLocaleDateString()}\n`;
      report += `   ‚Ä¢ Ïú†Ìö® Ï¢ÖÎ£åÏùº: ${new Date(cert.validTo).toLocaleDateString()}\n`;
      report += `   ‚Ä¢ ÏùºÎ†®Î≤àÌò∏: ${cert.serialNumber}\n`;
      report += `   ‚Ä¢ ÏßÄÎ¨∏: ${cert.fingerprint}\n`;
      report += `   ‚Ä¢ ÎßåÎ£åÍπåÏßÄ ÎÇ®ÏùÄ ÏùºÏàò: ${cert.daysUntilExpiry}Ïùº\n\n`;
      
      // Status analysis
      switch (result.certificateStatus) {
        case 'valid':
          report += `‚úÖ Ïù∏Ï¶ùÏÑú ÏÉÅÌÉú: Ïú†Ìö®Ìï®\n`;
          report += `üéØ Ïù¥ Ïù∏Ï¶ùÏÑúÎäî Ïò¨Î∞îÎ•¥Í≤å Íµ¨ÏÑ±ÎêòÏñ¥ ÏûàÍ≥† Ïã†Î¢∞Ìï† Ïàò ÏûàÏäµÎãàÎã§\n`;
          break;
        case 'expired':
          report += `‚ùå Ïù∏Ï¶ùÏÑú ÏÉÅÌÉú: ÎßåÎ£åÎê®\n`;
          report += `‚ö†Ô∏è Ïù¥ Ïù∏Ï¶ùÏÑúÎäî ÎßåÎ£åÎêòÏóàÏúºÎ©∞ Í∞±Ïã†Ïù¥ ÌïÑÏöîÌï©ÎãàÎã§\n`;
          break;
        case 'self-signed':
          report += `‚ö†Ô∏è Ïù∏Ï¶ùÏÑú ÏÉÅÌÉú: ÏûêÏ≤¥ ÏÑúÎ™Ö\n`;
          report += `üîí Ïù¥ Ïù∏Ï¶ùÏÑúÎäî Î∏åÎùºÏö∞Ï†ÄÏóêÏÑú Ïã†Î¢∞ÎêòÏßÄ ÏïäÏäµÎãàÎã§\n`;
          break;
        case 'invalid':
          report += `‚ùå Ïù∏Ï¶ùÏÑú ÏÉÅÌÉú: Ïú†Ìö®ÌïòÏßÄ ÏïäÏùå\n`;
          report += `üö´ Ïù¥ Ïù∏Ï¶ùÏÑúÏóêÎäî Íµ¨ÏÑ± Î¨∏Ï†úÍ∞Ä ÏûàÏäµÎãàÎã§\n`;
          break;
        case 'error':
          report += `‚ùå Ïù∏Ï¶ùÏÑú ÏÉÅÌÉú: Ïò§Î•ò\n`;
          report += `üö´ Ïù∏Ï¶ùÏÑúÎ•º Î∂ÑÏÑùÌï† Ïàò ÏóÜÏäµÎãàÎã§\n`;
          break;
      }
    } else if (result.error) {
      report += `‚ùå Ïò§Î•ò: ${result.error}\n`;
    }
    
    return report;
  }

  /**
   * Step 3: Analyze Security Headers
   * Checks if the website has proper security headers configured
   */
  static async analyzeSecurityHeaders(url: string): Promise<SecurityHeadersResult> {
    const timestamp = new Date().toISOString();
    
    try {
      // First check if the website is accessible
      const accessibilityResult = await this.analyzeWebsiteAccessibility(url);
      
      if (!accessibilityResult.accessible) {
        return {
          headers: [],
          missingHeaders: [],
          securityScore: 0,
          recommendations: ['ÏõπÏÇ¨Ïù¥Ìä∏Ïóê Ï†ëÍ∑ºÌï† Ïàò ÏóÜÏñ¥ Î≥¥Ïïà Ìó§ÎçîÎ•º Î∂ÑÏÑùÌï† Ïàò ÏóÜÏäµÎãàÎã§'],
          error: 'ÏõπÏÇ¨Ïù¥Ìä∏Ïóê Ï†ëÍ∑ºÌï† Ïàò ÏóÜÏäµÎãàÎã§',
          timestamp
        };
      }

      // Fetch headers from the website
      const headers = await this.fetchSecurityHeaders(url);
      
      // Analyze security headers
      const securityHeaders = this.analyzeHeaders(headers);
      const missingHeaders = this.getMissingHeaders(securityHeaders);
      const securityScore = this.calculateSecurityScore(securityHeaders);
      const recommendations = this.generateSecurityRecommendations(securityHeaders, missingHeaders);

      return {
        headers: securityHeaders,
        missingHeaders,
        securityScore,
        recommendations,
        timestamp
      };
    } catch (error) {
      return {
        headers: [],
        missingHeaders: [],
        securityScore: 0,
        recommendations: ['Î≥¥Ïïà Ìó§Îçî Î∂ÑÏÑù Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§'],
        error: error instanceof Error ? error.message : 'Ïïå Ïàò ÏóÜÎäî Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§',
        timestamp
      };
    }
  }

  /**
   * Fetch security headers from a website
   */
  private static async fetchSecurityHeaders(url: string): Promise<Record<string, string>> {
    try {
      const normalizedUrl = this.normalizeUrl(url);
      const response = await fetch(normalizedUrl, {
        method: 'HEAD',
        mode: 'cors'
      });

      const headers: Record<string, string> = {};
      
      // Extract security-related headers
      const securityHeaderNames = [
        'strict-transport-security',
        'content-security-policy',
        'x-frame-options',
        'x-content-type-options',
        'x-xss-protection',
        'referrer-policy',
        'permissions-policy',
        'cross-origin-embedder-policy',
        'cross-origin-opener-policy',
        'cross-origin-resource-policy'
      ];

      securityHeaderNames.forEach(headerName => {
        const headerValue = response.headers.get(headerName);
        if (headerValue) {
          headers[headerName] = headerValue;
        }
      });

      return headers;
    } catch (error) {
      // If CORS fails, return empty headers
      return {};
    }
  }

  /**
   * Analyze security headers and determine their status
   */
  private static analyzeHeaders(headers: Record<string, string>): SecurityHeader[] {
    const securityHeaders: SecurityHeader[] = [];

    // HSTS (HTTP Strict Transport Security)
    securityHeaders.push({
      name: 'Strict-Transport-Security',
      value: headers['strict-transport-security'] || '',
      present: !!headers['strict-transport-security'],
      recommended: true,
      description: 'HTTPS Í∞ïÏ†ú ÏÇ¨Ïö© Î∞è Ïø†ÌÇ§ Î≥¥Ïïà Í∞ïÌôî'
    });

    // CSP (Content Security Policy)
    securityHeaders.push({
      name: 'Content-Security-Policy',
      value: headers['content-security-policy'] || '',
      present: !!headers['content-security-policy'],
      recommended: true,
      description: 'XSS Í≥µÍ≤© Î∞©ÏßÄ Î∞è Î¶¨ÏÜåÏä§ Î°úÎî© Ï†úÏñ¥'
    });

    // X-Frame-Options
    securityHeaders.push({
      name: 'X-Frame-Options',
      value: headers['x-frame-options'] || '',
      present: !!headers['x-frame-options'],
      recommended: true,
      description: 'ÌÅ¥Î¶≠Ïû¨ÌÇπ Í≥µÍ≤© Î∞©ÏßÄ'
    });

    // X-Content-Type-Options
    securityHeaders.push({
      name: 'X-Content-Type-Options',
      value: headers['x-content-type-options'] || '',
      present: !!headers['x-content-type-options'],
      recommended: true,
      description: 'MIME ÌÉÄÏûÖ Ïä§ÎãàÌïë Î∞©ÏßÄ'
    });

    // X-XSS-Protection
    securityHeaders.push({
      name: 'X-XSS-Protection',
      value: headers['x-xss-protection'] || '',
      present: !!headers['x-xss-protection'],
      recommended: true,
      description: 'XSS ÌïÑÌÑ∞ ÌôúÏÑ±Ìôî'
    });

    // Referrer-Policy
    securityHeaders.push({
      name: 'Referrer-Policy',
      value: headers['referrer-policy'] || '',
      present: !!headers['referrer-policy'],
      recommended: true,
      description: 'Î¶¨ÌçºÎü¨ Ï†ïÎ≥¥ Ï†úÏñ¥'
    });

    // Permissions-Policy
    securityHeaders.push({
      name: 'Permissions-Policy',
      value: headers['permissions-policy'] || '',
      present: !!headers['permissions-policy'],
      recommended: false,
      description: 'Î∏åÎùºÏö∞Ï†Ä Í∏∞Îä• Ï†ëÍ∑º Ï†úÏñ¥ (ÏÑ†ÌÉùÏÇ¨Ìï≠)'
    });

    return securityHeaders;
  }

  /**
   * Get list of missing recommended headers
   */
  private static getMissingHeaders(headers: SecurityHeader[]): string[] {
    return headers
      .filter(header => header.recommended && !header.present)
      .map(header => header.name);
  }

  /**
   * Calculate security score based on headers
   */
  private static calculateSecurityScore(headers: SecurityHeader[]): number {
    const recommendedHeaders = headers.filter(header => header.recommended);
    const presentHeaders = recommendedHeaders.filter(header => header.present);
    
    if (recommendedHeaders.length === 0) return 0;
    
    return Math.round((presentHeaders.length / recommendedHeaders.length) * 100);
  }

  /**
   * Generate security recommendations
   */
  private static generateSecurityRecommendations(headers: SecurityHeader[], missingHeaders: string[]): string[] {
    const recommendations: string[] = [];

    if (missingHeaders.length === 0) {
      recommendations.push('Î™®Îì† Í∂åÏû• Î≥¥Ïïà Ìó§ÎçîÍ∞Ä ÏÑ§Ï†ïÎêòÏñ¥ ÏûàÏäµÎãàÎã§!');
      return recommendations;
    }

    missingHeaders.forEach(headerName => {
      switch (headerName) {
        case 'Strict-Transport-Security':
          recommendations.push('HSTS Ìó§ÎçîÎ•º Ï∂îÍ∞ÄÌïòÏó¨ HTTPS Í∞ïÏ†ú ÏÇ¨Ïö©ÏùÑ ÏÑ§Ï†ïÌïòÏÑ∏Ïöî');
          break;
        case 'Content-Security-Policy':
          recommendations.push('CSP Ìó§ÎçîÎ•º Ï∂îÍ∞ÄÌïòÏó¨ XSS Í≥µÍ≤©ÏùÑ Î∞©ÏßÄÌïòÏÑ∏Ïöî');
          break;
        case 'X-Frame-Options':
          recommendations.push('X-Frame-Options Ìó§ÎçîÎ•º Ï∂îÍ∞ÄÌïòÏó¨ ÌÅ¥Î¶≠Ïû¨ÌÇπÏùÑ Î∞©ÏßÄÌïòÏÑ∏Ïöî');
          break;
        case 'X-Content-Type-Options':
          recommendations.push('X-Content-Type-Options: nosniff Ìó§ÎçîÎ•º Ï∂îÍ∞ÄÌïòÏÑ∏Ïöî');
          break;
        case 'X-XSS-Protection':
          recommendations.push('X-XSS-Protection Ìó§ÎçîÎ•º Ï∂îÍ∞ÄÌïòÏó¨ XSS ÌïÑÌÑ∞Î•º ÌôúÏÑ±ÌôîÌïòÏÑ∏Ïöî');
          break;
        case 'Referrer-Policy':
          recommendations.push('Referrer-Policy Ìó§ÎçîÎ•º Ï∂îÍ∞ÄÌïòÏó¨ Î¶¨ÌçºÎü¨ Ï†ïÎ≥¥Î•º Ï†úÏñ¥ÌïòÏÑ∏Ïöî');
          break;
      }
    });

    return recommendations;
  }

  /**
   * Generate a human-readable report from the security headers analysis
   */
  static generateSecurityHeadersReport(result: SecurityHeadersResult): string {
    let report = `üõ°Ô∏è Î≥¥Ïïà Ìó§Îçî Î∂ÑÏÑù Î≥¥Í≥†ÏÑú\n`;
    report += `üìÖ ÏÉùÏÑ±Ïùº: ${new Date(result.timestamp).toLocaleString()}\n\n`;
    
    report += `üìä Î≥¥Ïïà Ï†êÏàò: ${result.securityScore}/100\n\n`;
    
    if (result.headers.length > 0) {
      report += `üìã Î≥¥Ïïà Ìó§Îçî ÏÉÅÌÉú:\n`;
      result.headers.forEach(header => {
        const status = header.present ? '‚úÖ' : '‚ùå';
        const recommended = header.recommended ? ' (Í∂åÏû•)' : ' (ÏÑ†ÌÉù)';
        report += `   ${status} ${header.name}${recommended}\n`;
        if (header.present && header.value) {
          report += `      Í∞í: ${header.value}\n`;
        }
        report += `      ÏÑ§Î™Ö: ${header.description}\n\n`;
      });
    }
    
    if (result.missingHeaders.length > 0) {
      report += `‚ö†Ô∏è ÎàÑÎùΩÎêú Í∂åÏû• Ìó§Îçî:\n`;
      result.missingHeaders.forEach(header => {
        report += `   ‚Ä¢ ${header}\n`;
      });
      report += `\n`;
    }
    
    if (result.recommendations.length > 0) {
      report += `üí° Í∂åÏû•ÏÇ¨Ìï≠:\n`;
      result.recommendations.forEach(rec => {
        report += `   ‚Ä¢ ${rec}\n`;
      });
    }
    
    if (result.error) {
      report += `\n‚ùå Ïò§Î•ò: ${result.error}\n`;
    }
    
    return report;
  }

  /**
   * Step 4: Calculate Overall Security Grade
   * Determines security grade (A+ to F) based on SSL_Analyzer.md criteria
   */
  static calculateSecurityGrade(
    accessibility: WebsiteAccessibilityResult,
    certificate: SSLCertificateResult,
    securityHeaders: SecurityHeadersResult
  ): SecurityGrade {
    let baseScore = 0;
    const criticalIssues: string[] = [];
    const highIssues: string[] = [];
    const mediumIssues: string[] = [];
    const lowIssues: string[] = [];

    // Step 1: Basic SSL and accessibility checks (SSL_Analyzer.md criteria)
    if (!accessibility.accessible) {
      criticalIssues.push('ÏõπÏÇ¨Ïù¥Ìä∏Ïóê Ï†ëÍ∑ºÌï† Ïàò ÏóÜÏäµÎãàÎã§');
      return {
        grade: 'F',
        score: 0,
        description: 'ÏõπÏÇ¨Ïù¥Ìä∏Ïóê Ï†ëÍ∑ºÌï† Ïàò ÏóÜÏñ¥ Î∂ÑÏÑùÌï† Ïàò ÏóÜÏäµÎãàÎã§',
        criticalIssues,
        highIssues,
        mediumIssues,
        lowIssues
      };
    }

    if (!accessibility.hasSSL) {
      criticalIssues.push('HTTPS ÏÑúÎπÑÏä§Í∞Ä ÏóÜÏäµÎãàÎã§');
      return {
        grade: 'F',
        score: 0,
        description: 'HTTPS ÏÑúÎπÑÏä§Í∞Ä ÏóÜÏñ¥ Ïã¨Í∞ÅÌïú Î≥¥Ïïà Î¨∏Ï†úÍ∞Ä ÏûàÏäµÎãàÎã§',
        criticalIssues,
        highIssues,
        mediumIssues,
        lowIssues
      };
    }

    // Step 2: Certificate analysis (SSL_Analyzer.md criteria)
    if (certificate.certificateStatus === 'expired') {
      criticalIssues.push('SSL Ïù∏Ï¶ùÏÑúÍ∞Ä ÎßåÎ£åÎêòÏóàÏäµÎãàÎã§');
      return {
        grade: 'F',
        score: 0,
        description: 'ÎßåÎ£åÎêú SSL Ïù∏Ï¶ùÏÑúÎ°ú Ïù∏Ìï¥ Ïã¨Í∞ÅÌïú Î≥¥Ïïà Î¨∏Ï†úÍ∞Ä ÏûàÏäµÎãàÎã§',
        criticalIssues,
        highIssues,
        mediumIssues,
        lowIssues
      };
    }

    // Base score calculation according to SSL_Analyzer.md
    if (certificate.certificateStatus === 'self-signed') {
      baseScore = 30; // DÎì±Í∏â
      highIssues.push('ÏûêÏ≤¥ ÏÑúÎ™ÖÎêú SSL Ïù∏Ï¶ùÏÑúÎ•º ÏÇ¨Ïö©ÌïòÍ≥† ÏûàÏäµÎãàÎã§');
    } else if (certificate.certificateStatus === 'valid') {
      baseScore = 80; // BÎì±Í∏â
    } else if (certificate.certificateStatus === 'invalid') {
      baseScore = 30; // Treat invalid as self-signed for scoring
      highIssues.push('Ïú†Ìö®ÌïòÏßÄ ÏïäÏùÄ SSL Ïù∏Ï¶ùÏÑúÎ•º ÏÇ¨Ïö©ÌïòÍ≥† ÏûàÏäµÎãàÎã§');
    } else {
      baseScore = 0; // Error case
      criticalIssues.push('SSL Ïù∏Ï¶ùÏÑú Î∂ÑÏÑùÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§');
    }

    // Step 3: Security headers analysis (SSL_Analyzer.md criteria)
    const recommendedHeaders = securityHeaders.headers.filter(h => h.recommended);
    const presentHeaders = recommendedHeaders.filter(h => h.present);
    const missingHeaders = securityHeaders.missingHeaders;

    // Headers score addition according to SSL_Analyzer.md
    // More balanced approach: missing headers are Medium issues, not major penalties
    if (presentHeaders.length === recommendedHeaders.length && recommendedHeaders.length > 0) {
      // Î™®Îì† Ìó§Îçî ÏûàÏùå? ‚Üí +10Ï†ê
      baseScore += 10;
    } else if (presentHeaders.length >= recommendedHeaders.length * 0.5) {
      // 50% Ïù¥ÏÉÅ Ìó§Îçî ÏûàÏùå? ‚Üí +5Ï†ê (ÏùºÎ∂Ä Ìó§Îçî ÏûàÏùå)
      baseScore += 5;
    } else if (presentHeaders.length > 0) {
      // ÏùºÎ∂Ä Ìó§Îçî ÏûàÏùå? ‚Üí +2Ï†ê (ÏïΩÍ∞ÑÏùò Î≥¥ÎÑàÏä§)
      baseScore += 2;
    }
    // Ìó§Îçî ÏóÜÏùå? ‚Üí 0Ï†ê (Í∞êÏ†ê ÏóÜÏùå, Medium Ïù¥ÏäàÎ°úÎßå Î∂ÑÎ•ò)

    // Issue classification based on SSL_Analyzer.md
    if (certificate.certificateInfo && certificate.certificateInfo.daysUntilExpiry < 30) {
      mediumIssues.push(`SSL Ïù∏Ï¶ùÏÑúÍ∞Ä ${certificate.certificateInfo.daysUntilExpiry}Ïùº ÌõÑ ÎßåÎ£åÎê©ÎãàÎã§`);
    }

    // Specific header issues classification (based on risk matrix - all Medium severity)
    if (missingHeaders.includes('Strict-Transport-Security')) {
      mediumIssues.push('HSTS Ìó§ÎçîÍ∞Ä ÎàÑÎùΩÎêòÏñ¥ HTTPS Í∞ïÏ†ú ÏÇ¨Ïö©Ïù¥ ÏÑ§Ï†ïÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§');
    }
    if (missingHeaders.includes('Content-Security-Policy')) {
      mediumIssues.push('CSP Ìó§ÎçîÍ∞Ä ÎàÑÎùΩÎêòÏñ¥ XSS Í≥µÍ≤©Ïóê Ï∑®ÏïΩÌï©ÎãàÎã§');
    }
    if (missingHeaders.includes('X-Frame-Options')) {
      mediumIssues.push('X-Frame-Options Ìó§ÎçîÍ∞Ä ÎàÑÎùΩÎêòÏñ¥ ÌÅ¥Î¶≠Ïû¨ÌÇπÏóê Ï∑®ÏïΩÌï©ÎãàÎã§');
    }
    if (missingHeaders.includes('X-Content-Type-Options')) {
      mediumIssues.push('X-Content-Type-Options Ìó§ÎçîÍ∞Ä ÎàÑÎùΩÎêòÏñ¥ MIME ÌÉÄÏûÖ Ïä§ÎãàÌïëÏóê Ï∑®ÏïΩÌï©ÎãàÎã§');
    }
    if (missingHeaders.includes('X-XSS-Protection')) {
      mediumIssues.push('X-XSS-Protection Ìó§ÎçîÍ∞Ä ÎàÑÎùΩÎêòÏñ¥ XSS ÌïÑÌÑ∞Í∞Ä ÎπÑÌôúÏÑ±ÌôîÎêòÏñ¥ ÏûàÏäµÎãàÎã§');
    }
    if (missingHeaders.includes('Referrer-Policy')) {
      mediumIssues.push('Referrer-Policy Ìó§ÎçîÍ∞Ä ÎàÑÎùΩÎêòÏñ¥ Î¶¨ÌçºÎü¨ Ï†ïÎ≥¥Í∞Ä ÎÖ∏Ï∂úÎê† Ïàò ÏûàÏäµÎãàÎã§');
    }

    // Final grade determination based on SSL_Analyzer.md scoring
    let grade: 'A+' | 'A' | 'B' | 'C' | 'D' | 'F';
    let description: string;

    if (baseScore >= 95) {
      grade = 'A+';
      description = 'ÏôÑÎ≤ΩÌïú Î≥¥Ïïà ÏÑ§Ï†ïÏûÖÎãàÎã§';
    } else if (baseScore >= 90) {
      grade = 'A';
      description = 'Ïö∞ÏàòÌïú Î≥¥Ïïà ÏàòÏ§ÄÏûÖÎãàÎã§';
    } else if (baseScore >= 80) {
      grade = 'B';
      description = 'ÏñëÌò∏Ìïú Î≥¥Ïïà ÏàòÏ§ÄÏûÖÎãàÎã§';
    } else if (baseScore >= 70) {
      grade = 'C';
      description = 'Î≥¥ÌÜµ ÏàòÏ§ÄÏùò Î≥¥ÏïàÏûÖÎãàÎã§';
    } else if (baseScore >= 50) {
      grade = 'D';
      description = 'Î≥¥Ïïà Í∞úÏÑ†Ïù¥ ÌïÑÏöîÌï©ÎãàÎã§';
    } else {
      grade = 'F';
      description = 'Ïã¨Í∞ÅÌïú Î≥¥Ïïà Î¨∏Ï†úÍ∞Ä ÏûàÏäµÎãàÎã§';
    }

    return {
      grade,
      score: Math.max(0, Math.min(100, baseScore)),
      description,
      criticalIssues,
      highIssues,
      mediumIssues,
      lowIssues
    };
  }

  /**
   * Generate a comprehensive security grade report
   */
  static generateSecurityGradeReport(grade: SecurityGrade): string {
    let report = `üèÜ Î≥¥Ïïà Îì±Í∏â Î∂ÑÏÑù Î≥¥Í≥†ÏÑú\n`;
    report += `üìÖ ÏÉùÏÑ±Ïùº: ${new Date().toLocaleString()}\n\n`;
    
    report += `üéØ ÏµúÏ¢Ö Î≥¥Ïïà Îì±Í∏â: ${grade.grade} (${grade.score}/100Ï†ê)\n`;
    report += `üìù ÌèâÍ∞Ä: ${grade.description}\n\n`;
    
    if (grade.criticalIssues.length > 0) {
      report += `üö® ÏπòÎ™ÖÏ†Å Î¨∏Ï†úÏ†ê:\n`;
      grade.criticalIssues.forEach(issue => {
        report += `   ‚Ä¢ ${issue}\n`;
      });
      report += `\n`;
    }
    
    if (grade.highIssues.length > 0) {
      report += `‚ö†Ô∏è ÎÜíÏùÄ Ïö∞ÏÑ†ÏàúÏúÑ Î¨∏Ï†úÏ†ê:\n`;
      grade.highIssues.forEach(issue => {
        report += `   ‚Ä¢ ${issue}\n`;
      });
      report += `\n`;
    }
    
    if (grade.mediumIssues.length > 0) {
      report += `üî∂ Ï§ëÍ∞Ñ Ïö∞ÏÑ†ÏàúÏúÑ Î¨∏Ï†úÏ†ê:\n`;
      grade.mediumIssues.forEach(issue => {
        report += `   ‚Ä¢ ${issue}\n`;
      });
      report += `\n`;
    }
    
    if (grade.lowIssues.length > 0) {
      report += `üî∏ ÎÇÆÏùÄ Ïö∞ÏÑ†ÏàúÏúÑ Î¨∏Ï†úÏ†ê:\n`;
      grade.lowIssues.forEach(issue => {
        report += `   ‚Ä¢ ${issue}\n`;
      });
      report += `\n`;
    }
    
    if (grade.criticalIssues.length === 0 && grade.highIssues.length === 0) {
      report += `‚úÖ Ïã¨Í∞ÅÌïú Î≥¥Ïïà Î¨∏Ï†úÍ∞Ä Î∞úÍ≤¨ÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§!\n`;
    }
    
    return report;
  }

  /**
   * Complete SSL analysis including all steps and security grade calculation
   */
  static async performCompleteAnalysis(url: string): Promise<OverallSecurityResult> {
    const accessibility = await this.analyzeWebsiteAccessibility(url);
    const certificate = await this.analyzeSSLCertificate(url);
    const securityHeaders = await this.analyzeSecurityHeaders(url);
    
    // Calculate overall security grade
    const grade = this.calculateSecurityGrade(accessibility, certificate, securityHeaders);
    
    // Calculate business impact
    const businessImpact = this.calculateBusinessImpact(grade);
    
    // Generate combined report
    let combinedReport = `üîç ÏôÑÏ†ÑÌïú SSL Î≥¥Ïïà Î∂ÑÏÑù\n`;
    combinedReport += `üìÖ ÏÉùÏÑ±Ïùº: ${new Date().toLocaleString()}\n`;
    combinedReport += `üåê ÏõπÏÇ¨Ïù¥Ìä∏: ${url}\n\n`;
    
    combinedReport += `=== Î≥¥Ïïà Îì±Í∏â ===\n`;
    combinedReport += this.generateSecurityGradeReport(grade);
    combinedReport += `\n\n=== ÎπÑÏ¶àÎãàÏä§ ÏòÅÌñ• Î∂ÑÏÑù ===\n`;
    combinedReport += businessImpact.report;
    combinedReport += `\n\n=== ÏõπÏÇ¨Ïù¥Ìä∏ Ï†ëÍ∑ºÏÑ± ===\n`;
    combinedReport += this.generateAccessibilityReport(accessibility);
    combinedReport += `\n\n=== SSL Ïù∏Ï¶ùÏÑú Î∂ÑÏÑù ===\n`;
    combinedReport += this.generateCertificateReport(certificate);
    combinedReport += `\n\n=== Î≥¥Ïïà Ìó§Îçî Î∂ÑÏÑù ===\n`;
    combinedReport += this.generateSecurityHeadersReport(securityHeaders);
    
    return {
      grade,
      accessibility,
      certificate,
      securityHeaders,
      businessImpact,
      combinedReport,
      timestamp: new Date().toISOString()
    };
  }

  /**
   * Step 5: Calculate Business Impact
   * Calculates potential business losses based on security grade
   */
  static calculateBusinessImpact(grade: SecurityGrade): BusinessImpactResult {
    // Í∏∞Î≥∏ Í∞ÄÏ†ï ÏÑ§Ï†ï (SSL_Analyzer.md Í∏∞Ï§Ä)
    const monthlyVisitors = 10000; // Ïõî Î∞©Î¨∏Ïûê
    const conversionRate = 0.02; // Ï†ÑÌôòÏú® 2% (100Î™Ö Ï§ë 2Î™ÖÏù¥ Í≥†Í∞ù)
    const orderConversionRate = 0.10; // Ï£ºÎ¨∏ Ï†ÑÌôòÏú® 10% (Í≥†Í∞ù Ï§ë 10%Í∞Ä Ïã§Ï†ú Íµ¨Îß§)
    const averageOrderValue = 50000000; // ÌèâÍ∑† Ï£ºÎ¨∏Í∏àÏï° 5Ï≤úÎßåÏõê

    // Î≥¥Ïïà Îì±Í∏âÎ≥Ñ ÏÜêÏã§Î•† (SSL_Analyzer.md Í∏∞Ï§Ä)
    let securityLossRate: number;
    let seoRankingLoss: number;
    let customerTrustLoss: number;
    let brandImageImpact: string;

    switch (grade.grade) {
      case 'F':
        securityLossRate = 0.50; // 50% ÏÜêÏã§
        seoRankingLoss = 40; // 40% ÌïòÎùΩ
        customerTrustLoss = 90; // 90% ÏÜêÏÉÅ
        brandImageImpact = 'Ïã¨Í∞ÅÌïú ÏÜêÏÉÅ';
        break;
      case 'D':
        securityLossRate = 0.30; // 30% ÏÜêÏã§
        seoRankingLoss = 30; // 30% ÌïòÎùΩ
        customerTrustLoss = 70; // 70% ÏÜêÏÉÅ
        brandImageImpact = 'ÏÉÅÎãπÌïú ÏÜêÏÉÅ';
        break;
      case 'C':
        securityLossRate = 0.20; // 20% ÏÜêÏã§
        seoRankingLoss = 25; // 25% ÌïòÎùΩ
        customerTrustLoss = 50; // 50% ÏÜêÏÉÅ
        brandImageImpact = 'Ï§ëÍ∞Ñ ÏÜêÏÉÅ';
        break;
      case 'B':
        securityLossRate = 0.10; // 10% ÏÜêÏã§
        seoRankingLoss = 15; // 15% ÌïòÎùΩ
        customerTrustLoss = 30; // 30% ÏÜêÏÉÅ
        brandImageImpact = 'Í≤ΩÎØ∏Ìïú ÏÜêÏÉÅ';
        break;
      case 'A':
        securityLossRate = 0.05; // 5% ÏÜêÏã§
        seoRankingLoss = 5; // 5% ÌïòÎùΩ
        customerTrustLoss = 10; // 10% ÏÜêÏÉÅ
        brandImageImpact = 'ÏµúÏÜå ÏÜêÏÉÅ';
        break;
      case 'A+':
        securityLossRate = 0.02; // 2% ÏÜêÏã§
        seoRankingLoss = 0; // ÌïòÎùΩ ÏóÜÏùå
        customerTrustLoss = 5; // 5% ÏÜêÏÉÅ
        brandImageImpact = 'Í±∞Ïùò ÏóÜÏùå';
        break;
      default:
        securityLossRate = 0.50;
        seoRankingLoss = 40;
        customerTrustLoss = 90;
        brandImageImpact = 'Ïã¨Í∞ÅÌïú ÏÜêÏÉÅ';
    }

    // Ïó∞Í∞Ñ ÏÜêÏã§Ïï° Í≥ÑÏÇ∞
    const monthlyCustomers = monthlyVisitors * conversionRate;
    const monthlyOrders = monthlyCustomers * orderConversionRate;
    const monthlyRevenue = monthlyOrders * averageOrderValue;
    const annualRevenue = monthlyRevenue * 12;
    const annualLoss = annualRevenue * securityLossRate;

    // Ìà¨Ïûê ÎπÑÏö© Î∞è ROI Í≥ÑÏÇ∞
    const investmentCost = grade.grade === 'F' ? 5000000 : // FÎì±Í∏â: 500ÎßåÏõê (SSL Ïù∏Ï¶ùÏÑú + ÏÑ§Ï†ï)
                          grade.grade === 'D' ? 3000000 : // DÎì±Í∏â: 300ÎßåÏõê (Ïù∏Ï¶ùÏÑú ÍµêÏ≤¥)
                          grade.grade === 'C' ? 2000000 : // CÎì±Í∏â: 200ÎßåÏõê (Ìó§Îçî ÏÑ§Ï†ï)
                          grade.grade === 'B' ? 1000000 : // BÎì±Í∏â: 100ÎßåÏõê (ÏµúÏ†ÅÌôî)
                          grade.grade === 'A' ? 500000 : 0; // AÎì±Í∏â: 50ÎßåÏõê (Ïú†ÏßÄÎ≥¥Ïàò)

    const netBenefit = annualLoss - investmentCost;
    const roi = investmentCost > 0 ? (netBenefit / investmentCost) * 100 : 0;

    // Î≥¥Í≥†ÏÑú ÏÉùÏÑ±
    const report = this.generateBusinessImpactReport({
      monthlyVisitors,
      conversionRate,
      orderConversionRate,
      averageOrderValue,
      securityLossRate,
      annualLoss,
      seoRankingLoss,
      customerTrustLoss,
      brandImageImpact,
      roi,
      investmentCost,
      netBenefit,
      report: ''
    });

    return {
      monthlyVisitors,
      conversionRate,
      orderConversionRate,
      averageOrderValue,
      securityLossRate,
      annualLoss,
      seoRankingLoss,
      customerTrustLoss,
      brandImageImpact,
      roi,
      investmentCost,
      netBenefit,
      report
    };
  }

  /**
   * Generate business impact report
   */
  static generateBusinessImpactReport(impact: BusinessImpactResult): string {
    let report = `\n=== ÎπÑÏ¶àÎãàÏä§ ÏòÅÌñ• Î∂ÑÏÑù ===\n`;
    report += `Ïõî Î∞©Î¨∏Ïûê: ${impact.monthlyVisitors.toLocaleString()}Î™Ö\n`;
    report += `Ï†ÑÌôòÏú®: ${(impact.conversionRate * 100).toFixed(1)}%\n`;
    report += `Ï£ºÎ¨∏ Ï†ÑÌôòÏú®: ${(impact.orderConversionRate * 100).toFixed(1)}%\n`;
    report += `ÌèâÍ∑† Ï£ºÎ¨∏Í∏àÏï°: ${impact.averageOrderValue.toLocaleString()}Ïõê\n`;
    report += `Î≥¥Ïïà ÏÜêÏã§Î•†: ${(impact.securityLossRate * 100).toFixed(1)}%\n\n`;

    report += `üí∞ ÏÜêÏã§ Î∂ÑÏÑù:\n`;
    report += `Ïó∞Í∞Ñ ÏòàÏÉÅ ÏÜêÏã§: ${impact.annualLoss.toLocaleString()}Ïõê\n`;
    report += `SEO ÏàúÏúÑ ÌïòÎùΩ: ${impact.seoRankingLoss}%\n`;
    report += `Í≥†Í∞ù Ïã†Î¢∞ÎèÑ ÏÜêÏÉÅ: ${impact.customerTrustLoss}%\n`;
    report += `Î∏åÎûúÎìú Ïù¥ÎØ∏ÏßÄ: ${impact.brandImageImpact}\n\n`;

    report += `üí° Ìà¨Ïûê Î∂ÑÏÑù:\n`;
    report += `Í∂åÏû• Ìà¨ÏûêÎπÑÏö©: ${impact.investmentCost.toLocaleString()}Ïõê\n`;
    report += `Ïó∞Í∞Ñ ÏàúÏù¥Ïùµ: ${impact.netBenefit.toLocaleString()}Ïõê\n`;
    report += `Ìà¨Ïûê ÎåÄÎπÑ Ìö®Í≥º: ${impact.roi.toFixed(1)}Î∞∞ ROI\n\n`;

    if (impact.roi > 10) {
      report += `‚úÖ Í≤∞Î°†: Ï¶âÏãú Ìà¨Ïûê Í∂åÏû• (ÎÜíÏùÄ ROI)\n`;
    } else if (impact.roi > 5) {
      report += `‚úÖ Í≤∞Î°†: Ìà¨Ïûê Í∂åÏû• (ÏñëÌò∏Ìïú ROI)\n`;
    } else if (impact.roi > 0) {
      report += `‚ö†Ô∏è Í≤∞Î°†: Ïã†Ï§ëÌïú Í≤ÄÌÜ† ÌïÑÏöî\n`;
    } else {
      report += `‚ùå Í≤∞Î°†: Ìà¨Ïûê Ìö®Í≥º ÎØ∏ÎØ∏\n`;
    }

    return report;
  }
}
