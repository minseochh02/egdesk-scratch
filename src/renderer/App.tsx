import { MemoryRouter as Router, Routes, Route, Link, useLocation } from 'react-router-dom';
import { useState, useEffect, useCallback, useMemo } from 'react';
import WordPressConnector from './components/WordPressConnector';
import LocalServer from './components/LocalServer';
import CodeEditor from './components/CodeEditor';
import { AIKeysManager } from './components/AIKeysManager';
import { ChatInterface } from './components/ChatInterface';
import { AIEditor } from './components/AIEditor';
import { DualScreenDemo } from './components/DualScreenEditor/DualScreenDemo';
import './App.css';

interface FileSystemItem {
  name: string;
  type: 'folder' | 'file';
  path: string;
  isDirectory: boolean;
  isFile: boolean;
  isHidden: boolean;
  isSymlink: boolean;
}

interface SystemDirectory {
  name: string;
  path: string;
  icon: string;
}

function FinderUI() {
  const [currentPath, setCurrentPath] = useState<string>('');
  const [fileItems, setFileItems] = useState<FileSystemItem[]>([]);
  const [systemDirectories, setSystemDirectories] = useState<SystemDirectory[]>([]);
  const [selectedFiles, setSelectedFiles] = useState<string[]>([]);
  const [viewMode, setViewMode] = useState<'list' | 'grid'>('list');
  const [sortBy, setSortBy] = useState<'name' | 'date' | 'size' | 'type'>('name');
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string>('');

  // Debug: Monitor fileItems state changes
  useEffect(() => {
    console.log('fileItems state changed:', fileItems);
    console.log('fileItems length:', fileItems.length);
    console.log('fileItems content:', fileItems);
    
    // Force re-render when fileItems changes
    if (fileItems.length > 0) {
      console.log('Forcing re-render with', fileItems.length, 'items');
    }
  }, [fileItems]);

  // Debug: Monitor currentPath state changes
  useEffect(() => {
    console.log('currentPath state changed:', currentPath);
  }, [currentPath]);

  // Debug: Monitor render cycle (removed dependency array to prevent infinite renders)
  // useEffect(() => {
  //   console.log('FinderUI component rendered with:', {
  //     fileItemsLength: fileItems.length,
  //     currentPath,
  //     isLoading,
  //     error
  //   });
  // });

  // Initialize with home directory (only run once on mount)
  useEffect(() => {
    const initializeFileSystem = async () => {
      try {
        const homeDir = await window.electron.fileSystem.getHomeDirectory();
        const sysDirs = await window.electron.fileSystem.getSystemDirectories();
        
        setSystemDirectories(sysDirs);
        setCurrentPath(homeDir);
        await loadDirectory(homeDir);
      } catch (error) {
        console.error('Failed to initialize file system:', error);
        setError('ÌååÏùº ÏãúÏä§ÌÖúÏùÑ Ï¥àÍ∏∞ÌôîÌï† Ïàò ÏóÜÏäµÎãàÎã§.');
      }
    };

    initializeFileSystem();
  }, []); // Empty dependency array to run only once

  // Separate useEffect for sync completion listener
  useEffect(() => {
    // Listen for sync completion notifications
    const handleSyncCompleted = (syncData: any) => {
      console.log('Sync completed, refreshing Finder UI:', syncData);
      // If the current path is the same as the sync path, refresh the directory
      if (currentPath === syncData.syncPath || currentPath.startsWith(syncData.syncPath)) {
        loadDirectory(currentPath);
      }
    };

    // Listen for navigation requests to synced folders
    const handleNavigateToSyncedFolder = (navigationData: any) => {
      console.log('Navigation request to synced folder:', navigationData);
      // Navigate to the synced folder
      loadDirectory(navigationData.syncPath);
    };

    // Add event listeners
    window.electron.ipcRenderer.on('sync-completed', handleSyncCompleted);
    window.electron.ipcRenderer.on('navigate-to-synced-folder', handleNavigateToSyncedFolder);

    // Cleanup event listeners
    return () => {
      // Note: In a real implementation, you'd want to properly remove the event listener
      // For now, we'll rely on the component unmounting to clean up
    };
  }, [currentPath]);

  const loadDirectory = useCallback(async (path: string) => {
    // Prevent loading the same directory multiple times
    if (currentPath === path && !isLoading) {
      console.log(`Directory ${path} already loaded, skipping`);
      return;
    }

    setIsLoading(true);
    setError('');
    
    try {
      console.log(`Loading directory: ${path}`);
      const result = await window.electron.fileSystem.readDirectory(path);
      
      if (result.success && result.items) {
        console.log(`Received ${result.items.length} items from main process`);
        
        // Validate the data structure
        if (!Array.isArray(result.items)) {
          console.error('Items is not an array:', typeof result.items);
          setError('ÏûòÎ™ªÎêú Îç∞Ïù¥ÌÑ∞ ÌòïÏãùÏûÖÎãàÎã§.');
          return;
        }
        
        // Check if items have required properties
        const validItems = result.items.filter(item => {
          if (!item.name || !item.path) {
            console.error('Invalid item:', item);
            return false;
          }
          return true;
        });
        
        console.log(`Valid items: ${validItems.length}`);
        
        // Batch state updates to prevent multiple renders
        setFileItems(validItems);
        setCurrentPath(path);
        
        console.log('State update completed. Current fileItems length should be:', validItems.length);
      } else {
        console.error('Failed to load directory:', result);
        setError(result.error || 'Ìè¥ÎçîÎ•º ÏùΩÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.');
        setFileItems([]);
      }
    } catch (error) {
      console.error('Error loading directory:', error);
      setError('Ìè¥ÎçîÎ•º Î°úÎìúÌïòÎäî Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.');
      setFileItems([]);
    } finally {
      setIsLoading(false);
    }
  }, [currentPath, isLoading]);

  const handleFileSelect = useCallback((filePath: string, isMultiSelect: boolean) => {
    if (isMultiSelect) {
      setSelectedFiles(prev => 
        prev.includes(filePath) 
          ? prev.filter(f => f !== filePath)
          : [...prev, filePath]
      );
    } else {
      setSelectedFiles([filePath]);
    }
  }, []);

  const handleFileDoubleClick = useCallback(async (item: FileSystemItem) => {
    if (item.isDirectory) {
      await loadDirectory(item.path);
    } else {
      // ÌååÏùº Ïó¥Í∏∞ (ÏãúÏä§ÌÖú Í∏∞Î≥∏ Ïï±ÏúºÎ°ú)
      console.log('Opening file:', item.path);
    }
  }, [loadDirectory]);

  const navigateToParent = useCallback(async () => {
    const parentPath = currentPath.split('/').slice(0, -1).join('/') || '/';
    await loadDirectory(parentPath);
  }, [currentPath, loadDirectory]);

  const navigateToHome = useCallback(async () => {
    const homeDir = await window.electron.fileSystem.getHomeDirectory();
    await loadDirectory(homeDir);
  }, [loadDirectory]);

  const getFileIcon = (item: FileSystemItem) => {
    if (item.isDirectory) return 'üìÅ';
    if (item.isSymlink) return 'üîó';
    
    const ext = item.name.split('.').pop()?.toLowerCase();
    switch (ext) {
      case 'pdf': return 'üìÑ';
      case 'jpg':
      case 'jpeg':
      case 'png':
      case 'gif': return 'üñºÔ∏è';
      case 'js':
      case 'ts':
      case 'jsx':
      case 'tsx': return 'üíª';
      case 'md': return 'üìù';
      case 'txt': return 'üìÑ';
      case 'mp4':
      case 'avi':
      case 'mov': return 'üé¨';
      case 'mp3':
      case 'wav':
      case 'flac': return 'üéµ';
      default: return 'üìÑ';
    }
  };

  const getFileSize = (item: FileSystemItem) => {
    if (item.isDirectory) return '--';
    // Ïã§Ï†ú ÌååÏùº ÌÅ¨Í∏∞Îäî ÎÇòÏ§ëÏóê Íµ¨ÌòÑ
    return '--';
  };

  const getFileDate = (item: FileSystemItem) => {
    // Ïã§Ï†ú ÌååÏùº ÎÇ†ÏßúÎäî ÎÇòÏ§ëÏóê Íµ¨ÌòÑ
    return '--';
  };

  const getFileType = (item: FileSystemItem) => {
    if (item.isDirectory) return 'Ìè¥Îçî';
    if (item.isSymlink) return 'Î∞îÎ°úÍ∞ÄÍ∏∞';
    
    const ext = item.name.split('.').pop()?.toLowerCase();
    switch (ext) {
      case 'pdf': return 'PDF Î¨∏ÏÑú';
      case 'jpg':
      case 'jpeg':
      case 'png':
      case 'gif': return 'Ïù¥ÎØ∏ÏßÄ';
      case 'js':
      case 'ts':
      case 'jsx':
      case 'tsx': return 'JavaScript';
      case 'md': return 'ÎßàÌÅ¨Îã§Ïö¥';
      case 'txt': return 'ÌÖçÏä§Ìä∏';
      case 'mp4':
      case 'avi':
      case 'mov': return 'ÎπÑÎîîÏò§';
      case 'mp3':
      case 'wav':
      case 'flac': return 'Ïò§ÎîîÏò§';
      default: return 'ÌååÏùº';
    }
  };

  const pathParts = useMemo(() => {
    const parts = currentPath.split('/').filter(Boolean);
    return parts.map((part, index) => ({
      name: part,
      path: '/' + parts.slice(0, index + 1).join('/')
    }));
  }, [currentPath]);

  return (
    <div className="finder-container">
      {/* Toolbar */}
      <div className="finder-toolbar">
        <div className="toolbar-left">
          <button className="toolbar-btn" onClick={navigateToParent} disabled={currentPath === '/'}>
            ‚Üê
          </button>
          <button className="toolbar-btn" onClick={navigateToHome}>
            üè†
          </button>
          <button className="toolbar-btn" onClick={() => loadDirectory(currentPath)} title="ÏÉàÎ°úÍ≥†Ïπ®">
            üîÑ
          </button>
          <div className="path-breadcrumb">
            {pathParts.map((part, index) => (
              <span 
                key={index}
                onClick={() => loadDirectory(part.path)}
                className="breadcrumb-item"
              >
                {part.name}
              </span>
            ))}
          </div>
        </div>
        <div className="toolbar-right">
          <button 
            className={`view-btn ${viewMode === 'grid' ? 'active' : ''}`}
            onClick={() => setViewMode('grid')}
          >
            ‚äû
          </button>
          <button 
            className={`view-btn ${viewMode === 'list' ? 'active' : ''}`}
            onClick={() => setViewMode('list')}
          >
            ‚ò∞
          </button>
        </div>
      </div>

      <div className="finder-content">
        {/* Sidebar */}
        <div className="finder-sidebar">
          <div className="sidebar-section">
            <div className="sidebar-section-header">
              <span className="sidebar-icon">‚≠ê</span>
              <span className="sidebar-title">Ï¶êÍ≤®Ï∞æÍ∏∞</span>
            </div>
            <ul className="sidebar-items">
              {systemDirectories.map((dir, index) => (
                <li 
                  key={index} 
                  className="sidebar-item"
                  onClick={() => loadDirectory(dir.path)}
                >
                  <span className="sidebar-icon">{dir.icon}</span>
                  <span>{dir.name}</span>
                </li>
              ))}
            </ul>
          </div>
        </div>

        {/* Main Content Area */}
        <div className="finder-main">
          {/* File List Header */}
          <div className="file-list-header">
            <div className="header-cell" onClick={() => setSortBy('name')}>
              Ïù¥Î¶Ñ {sortBy === 'name' && '‚Üì'}
            </div>
            <div className="header-cell" onClick={() => setSortBy('date')}>
              ÏàòÏ†ïÎêú ÎÇ†Ïßú {sortBy === 'date' && '‚Üì'}
            </div>
            <div className="header-cell" onClick={() => setSortBy('size')}>
              ÌÅ¨Í∏∞ {sortBy === 'size' && '‚Üì'}
            </div>
            <div className="header-cell" onClick={() => setSortBy('type')}>
              Ï¢ÖÎ•ò {sortBy === 'type' && '‚Üì'}
            </div>
          </div>

          {/* File List */}
          <div className={`file-list ${viewMode}`}>
            {isLoading ? (
              <div className="loading-indicator">
                <div className="spinner"></div>
                <p>Ìè¥ÎçîÎ•º Î°úÎìúÌïòÎäî Ï§ë...</p>
              </div>
            ) : error ? (
              <div className="error-indicator">
                <p>‚ùå {error}</p>
              </div>
            ) : fileItems.length === 0 ? (
              <div className="empty-indicator">
                <p>üìÅ Ïù¥ Ìè¥ÎçîÎäî ÎπÑÏñ¥ÏûàÏäµÎãàÎã§</p>
              </div>
            ) : (
              fileItems.map((item, index) => (
                <div
                  key={`${item.path}-${index}`}
                  className={`file-item ${selectedFiles.includes(item.path) ? 'selected' : ''} ${item.isHidden ? 'hidden' : ''}`}
                  onClick={(e) => handleFileSelect(item.path, e.metaKey || e.ctrlKey)}
                  onDoubleClick={() => handleFileDoubleClick(item)}
                >
                  <div className="file-icon">{getFileIcon(item)}</div>
                  <div className="file-name">{item.name}</div>
                  {viewMode === 'list' && (
                    <>
                      <div className="file-date">{getFileDate(item)}</div>
                      <div className="file-size">{getFileSize(item)}</div>
                      <div className="file-type">{getFileType(item)}</div>
                    </>
                  )}
                </div>
              ))
            )}
          </div>
        </div>
      </div>

      {/* Status Bar */}
      <div className="finder-statusbar">
        <span>{selectedFiles.length}Í∞ú Ìï≠Î™© ÏÑ†ÌÉùÎê®</span>
        <span>{fileItems.length}Í∞ú Ìï≠Î™©</span>
        <span>{currentPath}</span>
      </div>
    </div>
  );
}

function NavigationBar() {
  const location = useLocation();
  
  return (
    <div className="navigation-bar">
      <nav className="nav-links">
        <Link 
          to="/" 
          className={`nav-link ${location.pathname === '/' ? 'active' : ''}`}
        >
          üìÅ ÌååÏù∏Îçî
        </Link>
        <Link 
          to="/wordpress" 
          className={`nav-link ${location.pathname === '/wordpress' ? 'active' : ''}`}
        >
          üåê WordPress
        </Link>
        <Link 
          to="/local-server" 
          className={`nav-link ${location.pathname === '/local-server' ? 'active' : ''}`}
        >
          üñ•Ô∏è Local Server
        </Link>
        <Link 
          to="/code-editor" 
          className={`nav-link ${location.pathname === '/code-editor' ? 'active' : ''}`}
        >
          üíª Code Editor
        </Link>
        <Link 
          to="/ai-keys" 
          className={`nav-link ${location.pathname === '/ai-keys' ? 'active' : ''}`}
        >
          ü§ñ AI Keys
        </Link>
        <Link 
          to="/chat" 
          className={`nav-link ${location.pathname === '/chat' ? 'active' : ''}`}
        >
          üí¨ AI Chat
        </Link>
        <Link 
          to="/dual-screen" 
          className={`nav-link ${location.pathname === '/dual-screen' ? 'active' : ''}`}
        >
          üñ•Ô∏è Dual Screen
        </Link>

      </nav>
    </div>
  );
}

export default function App() {
  return (
    <Router>
      <div className="app-container">
        <NavigationBar />
        <main className="main-content">
          <Routes>
            <Route path="/" element={<FinderUI />} />
            <Route path="/wordpress" element={<WordPressConnector />} />
            <Route path="/local-server" element={<LocalServer />} />
            <Route path="/code-editor" element={<CodeEditor />} />
            <Route path="/ai-keys" element={<AIKeysManager />} />
            <Route path="/chat" element={<ChatInterface />} />
            <Route path="/dual-screen" element={<DualScreenDemo />} />
    
          </Routes>
        </main>
      </div>
    </Router>
  );
}
